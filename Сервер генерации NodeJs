import * as dotenv from 'dotenv';
import fetch from 'cross-fetch';
import OpenAI from 'openai';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import archiver from 'archiver';
import AWS from 'aws-sdk';
import { createApi } from 'unsplash-js';
import { templateHtml } from './../templates/business/001/template_index.js';
import slug from 'slug';
//import slug from 'limax';
import axios from 'axios';
import Replicate from 'replicate';
import { Agenda } from 'agenda';
import mongoose from 'mongoose';



dotenv.config();

const openaiApiKey = process.env.OPENAI_API_KEY;


const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION || 'us-east-1',
});

const unsplash = createApi({
  accessKey: process.env.UNSPLASH_ACCESS_KEY,
  fetch: fetch,
});

const pexelApiKey = process.env.PEXEL_API_KEY

const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN,
  fetch: fetch,
});


const openai = new OpenAI({
  apiKey: openaiApiKey
});

const clients = new Map(); // Use a Map for better client management

function addClient(client) {
  console.log('addClient: Adding client with track_id:', client.track_id);
  clients.set(client.track_id, client.res);
}

function removeClient(track_id) {
  console.log('removeClient: Removing client with track_id:', track_id);
  if (clients.has(track_id)) {
    const client = clients.get(track_id);
    if (client && client.end) {
      client.end(); // Ensure the response is ended properly
    }
    clients.delete(track_id);
  }
}


async function sendToClientWithUserId(track_id, message) {
 // console.log('sendToClientWithUserId: Preparing to send message to user with user_id:', track_id);

  const payload = {
    user_id: track_id,
    message: message,
  };

 // console.log('Payload to send:', JSON.stringify(payload));

  try {
    const response = await axios.post('https://telegrambotwhitepagegen.onrender.com/notify', payload);
    console.log(`Message sent to user with user_id: ${user_id}, response status: ${response.status}`);
  } catch (error) {
    if (error.response) {
      // Server responded with a status other than 200 range
      console.error('Error response data:', error.response.data);
      console.error('Error response status:', error.response.status);
      console.error('Error response headers:', error.response.headers);
    } else if (error.request) {
      // No response received from server
      console.error('No response received:', error.request);
    } else {
      // Other errors
      console.error('Error sending message with Axios:', error.message);
    }
  }
}
// Function to read random section from HTML files
function getRandomPartTop(filePath) {
  try {
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const top = fileContent;
    if (sections && sections.length > 0) {
      const randomIndex = Math.floor(Math.random() * sections.length);
      return sections[randomIndex];
    } else {
      throw new Error(`No sections found in ${filePath}`);
    }
  } catch (error) {
    console.error(`Error reading sections from ${filePath}:`, error);
    throw error;
  }
}

// (Similarly, update other template-building functions to use PHP)

// Function to generate text content using OpenAI GPT models...
// You can keep the GPT-3 specific code here as you had, no changes.


// Function to replace placeholders with PHP variables
function replacePlaceholdersWithPhp(template, data) {
  console.log('Replacing placeholders with PHP variables...');
  let phpTemplate = template;

  Object.keys(data).forEach(key => {
    const searchExp = new RegExp(`{{${key}}}`, 'g');
    const replaceValue = `<?php echo isset($${key}) ? $${key} : ''; ?>`;
    phpTemplate = phpTemplate.replace(searchExp, replaceValue);
  });

  return phpTemplate;
}

// Modify the ZIP creation function to store `.php` files instead of `.html`
async function savePhpToZip(newIndex, htmlContent, htmlContentServices, htmlContentAbout, htmlContentProduct, generatedHTMLpolicy, generatedHTMLblog, generatedHTMLblog2, generatedHTMLblog3, slug1, slug2, slug3, track_id, imageUrls, imagesAiResponse2, imagesAiResponse3, imagesAiResponseProduct, randomTemplateAssets, generatedHTMLthankyou) {
  return new Promise(async (resolve, reject) => {
    const outputPath = path.join(path.dirname(fileURLToPath(import.meta.url)), `${track_id}.zip`);
    const output = fs.createWriteStream(outputPath);
    const archive = archiver('zip', {
      zlib: { level: 9 }  
    });

    output.on('close', () => {
      console.log('Archiver finished, output file descriptor closed.');
      resolve(outputPath);
    });

    archive.on('error', (err) => {
      reject(err);
    });

    archive.pipe(output);
    
    // Add PHP files into the archive
    archive.append(htmlContent, { name: `${newIndex}.php` });
    archive.append(htmlContentServices, { name: 'services.php' });
    archive.append(htmlContentAbout, { name: 'about.php' });
    archive.append(htmlContentProduct, { name: 'product.php' });
    archive.append(generatedHTMLpolicy, { name: 'policy.php' });
    archive.append(generatedHTMLblog, { name: slug1 + '.php' });
    archive.append(generatedHTMLblog2, { name: slug2 + '.php' });
    archive.append(generatedHTMLblog3, { name: slug3 + '.php' });
    archive.append(generatedHTMLthankyou, { name: 'thankyou.php' });
    

    // Add other assets, images, etc.
    // Merge and deduplicate image URLs
    let imagesArray = [...new Set([...imagesAiResponseProduct, ...imageUrls, ...imagesAiResponse2, ...imagesAiResponse3])];

    // Download images and add them to the 'images' folder in the ZIP
    try {
      for (let i = 0; i < imagesArray.length; i++) {
        const imageUrl = imagesArray[i];
        const imageResponse = await axios({
          method: 'GET',
          url: imageUrl,
          responseType: 'arraybuffer'
        });

        const imageFileName = `image${i + 1}.png`;

        // Append image directly to the ZIP under the 'images' folder
        archive.append(imageResponse.data, { name: `images/${imageFileName}` });
      }
    } catch (error) {
      console.error('Error downloading or saving the images:', error);
      reject(error);
      return;
    }

    const assetsPath = path.join(path.dirname(fileURLToPath(import.meta.url)), `./../templates/business/${randomTemplateAssets}/assets/`);
    if (fs.existsSync(assetsPath)) {
      archive.directory(assetsPath, 'assets');
    }

    archive.finalize();
  });
}
// service PAGE

// Function to build HTML template from blocks
function buildHtmlTemplatAboutPHP(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ¢ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñƒ Ðž ÐšÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['company_about', "team", 'footer_php'];

  let combinedHtmlabout = topHtml;

  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlabout += section;
    }

  });

  combinedHtmlabout += bottomHtml;
  return combinedHtmlabout;
}

async function generateTextWithLLM(promptConfig) {
    const { prompt, systemPrompt } = promptConfig;
    
    try {
      const response = await fetch('https://api.replicate.com/v1/models/anthropic/claude-3.7-sonnet/predictions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.REPLICATE_API_TOKEN}`,
          'Content-Type': 'application/json',
          'Prefer': 'wait'
        },
        body: JSON.stringify({
          input: {
            prompt,
            max_tokens: 8192,
            system_prompt: systemPrompt || "",
            max_image_resolution: 0.5
          }
        })
      });
      
      if (!response.ok) {
        throw new Error(`API request failed with status ${response.status}`);
      }
      
      const data = await response.json();
      return data.output;
    } catch (error) {
      console.error('Error in Replicate API request:', error);
      throw error;
    }
  }

  
  function generatePromptsForHTMLGeneration(style, siteConfig) {
    const { site_theme, site_language, contact_country, key_words, domain_name } = siteConfig;
    
    const basePrompt = `
  Generate a complete website for a ${site_theme} business in ${site_language} language.
  The website should include the following pages:
  - Home page with hero section, features, about us, services, products, testimonials, and contact form
  - About Us page with company history and mission
  - Services page with detailed service descriptions
  - Product page showcasing main products
  - Contact page with address in ${contact_country} and contact form
  - Privacy Policy page
  - Three blog posts related to the business theme
  
  Keywords for SEO: ${key_words}
  `;
  
    const styles = {
      minimalist: `
  ${basePrompt}
  Design style: Minimalist
  Use a clean, minimal design with ample white space, subtle animations, and focus on typography.
  Color scheme: Monochromatic with one accent color
  Typography: Sans-serif fonts, clear hierarchy
  Layout: Simple grid, lots of white space, clear sections
  Design elements: Minimal icons, subtle borders, clean forms
  `,
      corporate: `
  ${basePrompt}
  Design style: Corporate Professional
  Create a professional business appearance with structured layout and formal elements.
  Color scheme: Blue and gray palette with accent colors
  Typography: Professional serif and sans-serif combination
  Layout: Structured grid, clear business sections, organized information hierarchy
  Design elements: Charts, graphs, business icons, formal buttons
  `,
      creative: `
  ${basePrompt}
  Design style: Creative and Bold
  Design a vibrant and eye-catching website with creative elements and bold interactions.
  Color scheme: Vibrant complementary colors
  Typography: Creative mix of fonts, playful headings
  Layout: Asymmetric layout, creative section breaks, dynamic scrolling
  Design elements: Bold graphics, animated elements, creative forms, unique navigation
  `,
      ecommerce: `
  ${basePrompt}
  Design style: E-commerce Focused
  Develop a shopping-oriented website with product showcases and clear call-to-actions.
  Color scheme: Conversion-focused with clear CTAs
  Typography: Clean, readable fonts optimized for product descriptions
  Layout: Product grid, featured items carousel, category navigation
  Design elements: Product cards, rating systems, add-to-cart buttons, checkout elements
  `,
      gaming: `
  ${basePrompt}
  Design style: Gaming Portal
  Create an immersive gaming-themed website with interactive elements and game-like features.
  Color scheme: Dark theme with vibrant neon accents
  Typography: Futuristic/game-inspired fonts for headings, readable sans-serif for content
  Layout: Immersive sections, game-like navigation, achievement highlights
  Design elements: Progress bars, badges, game-inspired buttons, leaderboard-style tables
  
  Include a user registration form and interactive elements like calculators or mini-games.
  Avoid mentioning real money earnings or gambling elements.
  `,
      luxury: `
  ${basePrompt}
  Design style: Luxury and Premium
  Design an elegant and sophisticated website that conveys exclusivity and high-end quality.
  Color scheme: Black, gold, and neutral tones
  Typography: Elegant serif fonts, refined spacing
  Layout: Spacious layout with large imagery, sophisticated animations
  Design elements: High-quality product images, subtle animations, elegant forms
  `,
      news: `
  ${basePrompt}
  Design style: News/Magazine
  Create a content-focused website with clear article layouts and effective content categorization.
  Color scheme: Clear readable scheme with category color coding
  Typography: News-style headlines, readable body text
  Layout: Article grids, featured story sections, sidebar elements
  Design elements: Article cards, reading time indicators, share buttons, subscription forms
  `
    };
    
    return styles[style] || styles.minimalist;
  }

  
  async function processLLMResponse(llmResponse, siteConfig) {
    const { track_id, file_extension } = siteConfig;
    
    try {
      // Ð Ð°Ð·Ð´ÐµÐ»Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ð¹ HTML Ð½Ð° Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ñ‹Ðµ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹
      const pages = extractPagesFromResponse(llmResponse);
      
      // ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ Ð´Ð»Ñ ÑÐ°Ð¹Ñ‚Ð°
      const imageUrls = await prepareImagesForSite(siteConfig);
      
      // Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ ZIP-Ð°Ñ€Ñ…Ð¸Ð² Ñ ÑÐ°Ð¹Ñ‚Ð¾Ð¼
      const zipPath = await createSiteZipArchive(pages, imageUrls, track_id, file_extension);
      
      return {
        status: 'success',
        zipPath,
        message: 'Site generated successfully'
      };
    } catch (error) {
      console.error('Error processing LLM response:', error);
      return {
        status: 'error',
        message: error.message
      };
    }
  }
  

// Function to build HTML template from blocks
function buildHtmlTemplateProductPHP(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ› ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÐšÐ¾Ð´ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹ ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['company_product', 'services', 'contact', 'footer_php'];

  let combinedHtmlproduct = topHtml

  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlproduct += section;
    }

  });

  combinedHtmlproduct += bottomHtml;

  return combinedHtmlproduct;
}
//

// Function to generate text content using OpenAI GPT-4
async function translatedTextFromGPT4o(key_words, site_language) {
  console.log('translateTextFromGPT4');

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "user", content: `Translate and refine keywords "${key_words}" for image searching relevance in ${site_language} respose only key words splitted with ',' do not respose any comments, response 5 key words` }
      ],
      temperature: 0.2,
      max_tokens: 400,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    const translatedText = response.choices[0].message.content.trim();
    console.log('GPT4 response ok: Translated Text');

    //return refineKeywords(translatedText); // Use the refinement function
    return translatedText;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Failed to translate text using OpenAI');
  }
}



// Function to generate text content using OpenAI GPT-4
async function translatedThankYouFromGPT4o(site_language) {
  console.log('translateTextFromGPT4');

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "user", content: `
        1. Translate text "Thank you for subscribing!" to "${site_language}" response only translated text in JSON format
        as "thank_you" 
        2. Translate text "We're excited to have you on board! Stay tuned for the latest updates, tips, and exclusive content delivered right to your inbox." to "${site_language}" response only translated text in JSON format
        as "thank_you_text".
        ### Example Formatting: Return the content in JSON format structured as follows example:
Response only in the follow Example Json format! Example Json:
{
  "thank_you": "{{thank_you}}",
  "thank_you_text": "{{thank_you_text}}"
}
        ` }
      ],
      temperature: 0.2,
      max_tokens: 1000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    const translatedText = response.choices[0].message.content.trim();
   // console.log('GPT4 response ok: Translated Text');
    const generatedTextThankYou = translatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponseThankyou = JSON.parse(generatedTextThankYou);

    //return refineKeywords(translatedText); // Use the refinement function
    return jsonResponseThankyou;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Failed to translate text using OpenAI');
  }
}

 

// Function to generate text content using OpenAI GPT-4
async function transliterateAndSlugify(title) {
 // console.log('transliterateAndSlugify');

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "user", content: `Translitarate to english and refine keywords "${title}"  and response as human readable url, response only translitarated words without your comments` }
      ],
      temperature: 0.2,
      max_tokens: 400,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    const transliterateText = response.choices[0].message.content.trim();
   // console.log('GPT4 response ok: Translated Text');

    //return refineKeywords(translatedText); // Use the refinement function
    return transliterateText;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Failed to translate text using OpenAI');
  }
}


async function translatedTextPolicyFromGPT4omini(policy, site_language) {
  console.log('start translatedTextPolicyFromGPT4omini');

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "user", content: `Translate to ${site_language} text inside html, do not change html, do not translate html classes names ad data-attibutes, do not translate or remove {{brand_name}}, response in html format only, text in html to translate:  "${policy}" ` }
      ],
      temperature: 0.2,
      max_tokens: 3000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let translatedTextPolicy = response.choices[0].message.content.trim();
   // console.log('GPT4 response ok: Translated Text');
    // console.log(translatedTextPolicy);

    // Remove any surrounding ```html and ``` markdown syntax
    translatedTextPolicy = translatedTextPolicy.replace(/```html/g, '').replace(/```/g, '').trim();

    return translatedTextPolicy;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Failed to translate text using OpenAI');
  }
}

function generateSlugNew(title) {
  return title
    .toLowerCase()
    .replace(/\s+/g, '-')     // Replace spaces with dashes
    .replace(/-+/g, '-')
    .replace(/:/g, '');     // Replace multiple dashes with a single dash
}

async function generateTextBlogFromGPT4o(site_type, site_theme, site_language, contact_country, key_words, promptBlogTitle1, promptBlogShortText1) {
  console.log('generateTextBlogFromGPT4');

  const SYSTEM_PROMPT = `
You are an expert website copywriter tasked with generating comprehensive blog post content for a ${site_theme} website. 

The website will serve as a robust digital presence for the company, effectively communicating its mission, services, and products to potential customers. 
Based on 
### Parameters:
- **Site_Theme**: ${site_theme}
- **Site_Type**: ${site_type}
- **Keywords**: ${key_words}
- **Site_Language**: ${site_language}
- **contact_country**: ${contact_country}
- **Blog Post Title**: ${promptBlogTitle1}, 
- **Blog Post Short Text**: ${promptBlogShortText1}

### Special Instructions:
- Each paragraph should have 200-300 words of text. 
- Generate text for blog post about 2000-2300 words
- Generate content including:
  - include in text key words: "${key_words}" and use it to generate persuasive text blog post. Use 4-5 ${key_words} in text according to context.
### Content Requirements:
Generate engaging content in ${site_language}:
### Pages and Sections:

1. **Blog Title**: generate a blog post text around around 3000 words with sub-headers and 5 paragraphs and wrap sub-headers in html tag <h4> and wrap paragraphs in html tag <p>,  generate blog text on language: "${site_language}", based on ${promptBlogTitle1} and "${promptBlogShortText1}" and keywords: "${key_words}", ${site_theme} and in response as "text_blog".
   
### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Do not use any prohibited words or themes, jargon or themes as NSFW, do not use any politics topics.
3. Ensure the response is in valid JSON format.
4. Do not include backticks or single quotes in the response.
5. Validate the JSON format before sending the response.
6. Ensure the response has all generated text for all variables: "title_blog", "short_text_blog", "text_blog".
7. Make sure blog post text is around 2000 words.
8. Write a text in a casual and conversational style. 
9. Use shorter sentences and simple language. 
10. Include relatable examples or comparisons to make the information easy to understand. 
11. Make sure it feels like it's written by a person, not a machine.
12. Wrap sub-headers in HTML tag <h4> and wrap paragraphs in HTML tag <p>.

### Example Formatting: Return the content in JSON format structured as follows example:
Response only in the follow Example Json format! Example Json:
{
  "title_blog": "${promptBlogTitle1}",
  "short_text_blog": "${promptBlogShortText1}",
  "text_blog": "{{text_blog}}"
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.4,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Blog1 Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponseBlog = JSON.parse(generatedText);
 

    // Check if all required fields are present
    const requiredFields = ["title_blog", "short_text_blog", "text_blog"];

    for (const field of requiredFields) {
      if (!(field in jsonResponseBlog)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponseBlog;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


async function generateTextBlog2FromGPT4o(site_type, site_theme, site_language, contact_country, key_words, promptBlogTitle2, promptBlogShortText2) {
  console.log('generateTextBlogFromGPT4 2');

  const SYSTEM_PROMPT = `
You are an expert website copywriter tasked with generating comprehensive blog post content for a ${site_theme} website. 
The website will serve as a robust digital presence for the company, effectively communicating its mission, services, and products to potential customers. 
Based on 
### Parameters:
- **Site_Theme**: ${site_theme}
- **Site_Type**: ${site_type}
- **Keywords**: ${key_words}
- **Site_Language**: ${site_language}
- **contact_country**: ${contact_country}
- **Blog Post Title**: ${promptBlogTitle2}, 
- **Blog Post Short Text**: ${promptBlogShortText2}

### Special Instructions:
- Each paragraph should have 200-300 words of text. 
- Generate text for blog post about 2000-2300 words
- Generate content including:
  - include in text key words: "${key_words}" and use it to generate persuasive text blog post. Use 4-5 ${key_words} in text according to context.
### Content Requirements:
Generate engaging content in ${site_language}:
### Pages and Sections:

1. **Blog Title**: generate a blog post text around around 3000 words with sub-headers and 5 paragraphs and wrap sub-headers in html tag <h4> and wrap paragraphs in html tag <p>,  generate blog text on language: "${site_language}", based on ${promptBlogTitle2} and "${promptBlogShortText2}" and keywords: "${key_words}", ${site_theme} and in response as "text_blog_2".
   
### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Do not use any prohibited words or themes, jargon or themes as NSFW, do not use any politics topics.
3. Ensure the response is in valid JSON format.
4. Do not include backticks or single quotes in the response.
5. Validate the JSON format before sending the response.
6. Ensure the response has all generated text for all variables: : "title_blog_2", "short_text_blog_2", "text_blog_2".
7. Make sure blog post text is around 2000 words.
8. Write a text in a casual and conversational style. 
9. Use shorter sentences and simple language. 
10. Include relatable examples or comparisons to make the information easy to understand. 
11. Make sure it feels like it's written by a person, not a machine. 
12. Wrap sub-headers in HTML tag <h4> and wrap paragraphs in HTML tag <p>.


### Example Formatting: Return the content in JSON format structured as follows example:
Response only in the follow Example Json format! Example Json:
{
  "title_blog_2": "${promptBlogTitle2}",
  "short_text_blog_2": "${promptBlogShortText2}",
  "text_blog_2": "{{text_blog_2}}"
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.4,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Blog1 Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponseBlog2 = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = ["title_blog_2", "short_text_blog_2", "text_blog_2"];

    for (const field of requiredFields) {
      if (!(field in jsonResponseBlog2)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponseBlog2;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


async function generateTextBlog3FromGPT4o(site_type, site_theme, site_language, contact_country, key_words, promptBlogTitle3, promptBlogShortText3) {
 // console.log('generateTextBlogFromGPT4');


  const SYSTEM_PROMPT = `
You are an expert website copywriter tasked with generating comprehensive blog post content for a ${site_theme} website. 
The website will serve as a robust digital presence for the company, effectively communicating its mission, services, and products to potential customers. 
Based on 
### Parameters:
- **Site_Theme**: ${site_theme}
- **Site_Type**: ${site_type}
- **Keywords**: ${key_words}
- **Site_Language**: ${site_language}
- **contact_country**: ${contact_country}
- **Blog Post Title**: ${promptBlogTitle3}, 
- **Blog Post Short Text**: ${promptBlogShortText3}

### Special Instructions:
- Each paragraph should have 200-300 words of text. 
- Generate text for blog post about 2000-2300 words
- Generate content including:
  - include in text key words: "${key_words}" and use it to generate persuasive text blog post. Use 4-5 ${key_words} in text according to context.
### Content Requirements:
Generate engaging content in ${site_language}:
### Pages and Sections:

1. **Blog Title**: generate a blog post text around 3000 words with sub-headers and 5 paragraphs and wrap sub-headers in html tag <h4> and wrap paragraphs in html tag <p>,  generate blog text on language: "${site_language}", based on ${promptBlogTitle3} and "${promptBlogShortText3}" and keywords: "${key_words}", ${site_theme} and in response as "text_blog_2".
   
### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Do not use any prohibited words or themes, jargon or themes as NSFW, do not use any politics topics.
3. Ensure the response is in valid JSON format.
4. Do not include backticks or single quotes in the response.
5. Validate the JSON format before sending the response.
6. Ensure the response has all generated text for all variables: "title_blog_3", "short_text_blog_3", "text_blog_3".
7. Make sure blog post text is around 2000 words.
8. Write a text in a casual and conversational style. 
9. Use shorter sentences and simple language. 
10. Include relatable examples or comparisons to make the information easy to understand. 
11. Make sure it feels like it's written by a person, not a machine. 
12. Wrap sub-headers in HTML tag <h4> and wrap paragraphs in HTML tag <p>


### Example Formatting: Return the content in JSON format structured as follows example:
Response only in the follow Example Json format! Example Json:
{
  "title_blog_3": "${promptBlogTitle3}",
  "short_text_blog_3": "${promptBlogShortText3}",
  "text_blog_3": "{{text_blog_3}}"
}
`;

  //console.log('SYSTEM_PROMPT:  ', SYSTEM_PROMPT)
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.4,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    let generatedText = response.choices[0].message.content;
    //console.log('GPT4 response ok: Generated Blog1 Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponseBlog3 = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = ["title_blog_3", "short_text_blog_3", "text_blog_3"];

    for (const field of requiredFields) {
      if (!(field in jsonResponseBlog3)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponseBlog3;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}

// Function to generate text content using OpenAI GPT-4
async function generateTextFromGPT4o(site_type, site_theme, site_language, contact_country, key_words, domain_to_ai, brandName, stop_words_ai, track_id) {
 // console.log('generateTextFromGPT4');


  const SYSTEM_PROMPT = `
You are an expert website copywriter tasked with generating comprehensive content for a business websites, written by your text feels like it's written by a person, not a machine.
The website will serve as a robust digital presence for the company, effectively communicating its mission, services, and products to potential customers.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Site_Type**: ${site_type}
- **Key_words**: ${key_words}
- **Site_Language**: ${site_language}
- **contact_country**: ${contact_country}
- **domain_name**: ${brandName}

### Special Instructions:
- ### General Guidelines:
1. **Token Limit**: The total length of the generated text should not exceed 3500 tokens.
2. **JSON Structure**: The response must be formatted as valid JSON, with all required fields included. Ensure no missing fields.
3. **Clarity**: Use clear, simple language, and ensure all text feels natural and human-like.
4. **Content Structure**: Focus on generating content for each page in sequence. Ensure each section is complete before moving on to the next.
- Each paragraph should have 30-40 words of text.
- Generate text for all 5 pages in your response - Home, About us, Contacts, Services, Products
- Generate content including:
  - A brand name for the business that aligns with the ${site_theme}.
  - Value Proposition based on ${site_theme} and use it to generate persuasive text copy About us page. 
  - Ensure variation and creativity in sentence structure, vocabulary, and style for each page. Avoid repetition of phrases and concepts across the website.
${stop_words_ai}
### Content Requirements:
Generate engaging unique content in sound more personal and heartfelt maner on ${site_language} laguage the following pages:
### Pages and Sections:

1. **Index Page**:
   - **Sections**:
      1. Hero Section:
      ${domain_to_ai}
      - Create an engaging header title "hero_title_01"  , generate meta title ad response as "title_head", generate sub-title "hero_sub_title_text", generate paragraph "hero_text" about 100 words emphasizing the title with a value proposition for the brand name of the company based on ${key_words} for the ${site_theme} website. Generate text one word for Hero button and response as "hero_button"
      2. **Features**: write a list of features based on value proposition 
      - write on ${site_language} word "Features" and use it as "main_feature_title" in response.
      - Write 3 feature titles with features explained text: "feature_title_01", "feature_text_01", "feature_title_02", "feature_text_02", "feature_title_03", "feature_text_03"
      3. **About the Business**: Provide an overview of the business. 
      - write on ${site_language} words "About us" and use it as "about_us" in response.
      - write text about us text "about_us_text" based ${key_words} and use it to generate persuasive text copy About us text for company.
      4. **Services**: Highlight the key services offered.
      - services title write on ${site_language} words "Services" and use it as "service_header" in response.
      - write a services sub-header and use it as "services_sub_header" in response.
      - write a service text and use it as "service_header_text" in response.
      - write a 3 Services title and short paragraph text for each and use it as: "service_title_01", "service_text_01",  "service_title_02", "service_text_02",  "service_title_03", "service_text_03"  
      5. **Benefits**: Highlight 3 key benefits offered.
      - benefits title  write on ${site_language} words "Benefits" and use it as "benefit_title" in response.
      - write a benefits sub-title and use it as "benefits_sub_title" in response.
      - write a 3 benefits title and short paragraph text for each benefit and use it as: "bennefit_01", "benefit_text_01",  "benefit_02", "benefit_text_02",  "benefit_03", "benefit_text_03" 
      6. **Product** Describe product based on value proposition.
      - write product title and use it as "product_title_01" in response.
      - write product text 300 words and use it as "product_text_01" in response.
      7. **Team Information**: Introduce the team members and their roles.
           - team title write on ${site_language} words "Our team" and use it as "our_team_title" in response.
           - write 3 team person names and roles(based on business type ${site_theme} best for small and medium company size) use names and sur-names according to ${contact_country} 2 man and 1 woman and use it in response as: "team_member_man_01", "team_role_01", "team_member_man_02", "team_role_02", "team_member_woman_01", "team_role_03"
     8. **Contact**: Generate a concise footer text with contact information, Generate a real office address for a business in the capital city of ${contact_country}. The address should include a street name, building number, real zip code, and any additional details that make it appear authentic. Ensure the address and zip code is plausible within the context of capital of ${contact_country} and response as: "address_footer", and a random telephone number with the ${contact_country} country prefix.
     9. ***Navigation**: Translate navbar links text to ${site_language}  and use it as links in response: "Home" response as "home_link", "Features"  response as "features_link", "Services" response as "services_link", "Our Team" response as "team_link", "Contact" response as "contact_link", "About Us" response as "about_link".
     10. **Call-to-action**: Generate Call to action text base on Value Proposion and ${key_words} and button text and response as "call_to_action_title", geenrate call to action short text response as "call_to_action_text", generate call-to-action button text and response as "call_to_action_button", generate call-to-action button text and response as "button_footer".
     11. **Translate Form**: title and placeholders: Generate short engaging text for form response as "form_text", Translate "Send Us A Message" response as "form_title", "Message" response as "form_message", "Your Name" response as "form_name", "Your Email" response as "form_email", "Your Message" resposne as "form_message".
     12. **Site Meta**: Generate text for meta description response as "description_head", 
     13. ***Key Words*: Generate 7 key-words for SEO close in context for initial key words: "${key_words}" but all unique and different and response as "keywords_head".
     14. ***Testimonials*: Generate short Users Testimonials  reflected value proposition and enthusiastic tone and response all as: 
      - "Testimonial text 1" response as "testimonial_*" all testimonials - "testimonial_01" as testimonial_01, "Testimonial person business role" as "testimonial_role_01",  testimonial name as "testimonial_name_01,  use female name and sur-name according to ${contact_country} and use it in response as "testimonial_name_01,  
      - "Testimonial text 2" as "testimonial_02", "Testimonial person business role" as "testimonial_role_02", use male name and sur-name according to ${contact_country} testimoial 2 name as "testimonial_name_02", "Testimonial text 3" as "testimonial_03", "Testimonial person business role" as "testimonial_role_03", use male name and sur-name according to ${contact_country} testimonial 3 name and response as "testimonial_name_03".
     15. ***Footer*: Generate call to action title response as "call_to_action_footer", Translate text to ${site_language} "Services" response as "services_footer" , Translate "Product" response as "product", Translate "Contact Us" response as "contact".
     16.***Translate text***: Translate baner text: "We use cookies to ensure you get the best experience on our website." to ${site_language} and use in response as: "use_cookies". 
     17. Translate to ${site_language} words "Learn more" and use in response as: "learn_more". 
     18. Translate to ${site_language} word "Close" and use in response as: "i_agree".

    
2. **About Us Page**:
   - **Company History**: Describe the history of the company about 300 words response as "company_hystory"
   - **Mission and Values**: Outline the company's mission and core values about 200 words and response as "company_mission"
3. **Services Page**:
   - **Service Descriptions**: Offer detailed descriptions of the main services provided by the business about 500 word and response as "company_services"
4. **Products Page**:
   - **Products Descriptions**: describe the primary products offered by the business about 400 words ad response as "company_product".
5. **Contact Us Page**:
   - **Contact Details**: Provide comprehensive contact information, including location.
   - **Contact Form**: Include a user-friendly contact form for inquiries.
6. ***Traslate Key word to English***: Translate ${key_words} to English: and response as: "images_key_word".


### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Write a text in a casual and conversational style. 
6. Use shorter sentences and simple language. 
7. Include relatable examples or comparisons to make the information easy to understand. 
8. Make sure all generated text feels like it's written by a person, not a machine. 
9. Ensure uniqueness and creativity in the blog titles and content for each generation.
10. Do not use any harmful, illegal, unethical, or violent content of any kind in the generating text.
11. Ensure the response have all generated text for all variables: "title_head", "keywords_head", "description_head", "brand_name", "home_link", "features_link",
      "services_link", "team_link", "contact_link", "about_link", "hero_title_01", "hero_sub_title_text",
      "hero_text", "hero_button", "main_feature_title", "feature_title_01", "feature_text_01", "feature_title_02",
      "feature_text_02", "feature_title_03", "feature_text_03", "about_us", "about_us_text", "services_sub_header",
      "service_header", "service_header_text", "service_title_01", "service_text_01", "service_title_02",
      "service_text_02", "service_title_03", "service_text_03", "benefit_title", "benefits_sub_title", "bennefit_01",
      "benefit_text_01", "benefit_02", "benefit_text_02", "benefit_03", "benefit_text_03", "product_title_01",
      "product_text_01", "our_team_title", "team_member_man_01", "team_role_01", "team_member_man_02", "team_role_02",
      "team_member_woman_01", "team_role_03", "call_to_action_title", "call_to_action_text", "call_to_action_button",
      "testimonial_01", "testimonial_role_01", "testimonial_name_01", "testimonial_02", "testimonial_role_02",
      "testimonial_name_02", "testimonial_03", "testimonial_role_03", "form_title", "form_text", "form_name",
      "form_email", "form_message", "form_button", "call_to_action_footer", "button_footer", "address_footer",
      "services_footer", "product", "about_us", "contact", "tel_num", "call_to_action_footer", "images_key_word",
      "company_hystory", "company_mission", "company_services", "company_product", "use_cookies", "learn_more", "i_agree"
     

### Example Formatting: Return the content in JSON format for each 5 pages - index, about, services, products, contact, structured as follows example minimum 2000 symbols for every page maximum 7000 words for all pages:
Response only in the follow Example Json format! Example Json:
{
  "title_head": "{{title_head}}",
  "keywords_head": "{{keywords_head}}",
  "description_head": "{{description_head}}",
  "brand_name": "{{brand_name}}",
  "home_link": "{{home_link}}",
  "features_link": "{{features_link}}",
  "services_link": "{{services_link}}", 
  "team_link": "{{team_link}}", 
  "contact_link": "{{contact_link}}", 
  "about_link": "{{about_link}}",
  "hero_title_01": "{{hero_title_01}}:",
  "hero_sub_title_text": "{{hero_sub_title_text}}",
  "hero_text": "{{hero_text}}",
  "hero_button": "{{hero_button}}",
  "main_feature_title": "{{main_feature_title}}",
  "feature_title_01": "{{feature_title_01}}",
  "feature_text_01": "{{feature_text_01}}",
  "feature_title_02": "{{feature_title_02}}",
  "feature_text_02": "{{feature_text_02}}",
  "feature_title_03": "{{feature_title_03}}",
  "feature_text_03": "{{feature_text_03}}",
  "about_us": "{{about_us}}",
  "about_us_text": "{{about_us_text}}",
  "services_sub_header": "{{services_sub_header}}",
  "service_header": "{{service_header}}",
  "service_header_text": "{{service_header_text}}",
  "service_title_01": "{{service_title_01}}",
  "service_text_01": "{{service_text_01}}",
  "service_title_02": "{{service_title_02}}",
  "service_text_02": "{{service_text_02}}",
  "service_title_03": "{{service_title_03}}",
  "service_text_03": "{{service_text_03}}",
  "benefit_title": "{{benefit_title}}",
  "benefits_sub_title": "{{benefits_sub_title}}",
  "bennefit_01": "{{bennefit_01}}",
  "benefit_text_01": "{{benefit_text_01}}",
  "benefit_02": "{{benefit_02}}",
  "benefit_text_02": "{{benefit_text_02}}",
  "benefit_03": "{{benefit_03}}",
  "benefit_text_03": {"benefit_text_03}}",
  "product_title_01": "{{product_title_01}}",
  "product_text_01": "{{product_text_01}}",
  "our_team_title": "{{our_team_title}}",
  "team_member_man_01": "{{team_member_man_01}}",
  "team_role_01": "{{team_role_01}}",
  "team_member_man_02": "{{team_member_man_02}}",
  "team_role_02": "{{team_role_02}}",
  "team_member_woman_01": "{{team_member_woman_01}}",
  "team_role_03": "{{team_role_03}}",
  "call_to_action_title": "{{call_to_action_title}}",
  "call_to_action_text": "{{call_to_action_text}}",
  "call_to_action_button": "{{call_to_action_button}}",
  "testimonial_01": "{{testimonial_01}}",
  "testimonial_role_01": "{{testimonial_role_01}}",
  "testimonial_name_01": "{{testimonial_name_01}}",
  "testimonial_02": "{{testimonial_02}}",
  "testimonial_role_02": "{{testimonial_role_02}}",
  "testimonial_name_02": "{{testimonial_name_02}}",
  "testimonial_03": "{{testimonial_03}}",
  "testimonial_role_03": {{"testimonial_role_03}}",
  "form_title": "{{form_title}}",
  "form_text": "{{form_text}}",
  "form_name": "{{form_name}}",
  "form_email": "{{form_email}}",
  "form_message": "{{form_message}}",
  "form_button": "{{form_button}}",
  "call_to_action_footer": "{{call_to_action_footer}}",
  "button_footer": "{{button_footer}}",
  "address_footer": "{{address_footer}}",
  "services_footer": "{{services_footer}}",
  "product": "{{product}}",
  "about_us": "{{about_us}}",
  "contact": "{{contact}}",
  "tel_num": "{{tel_num}}"
  "call_to_action_footer": "{{call_to_action_footer}}",
    "images_key_word": "{{images_key_word}}",
    "company_hystory": "{{company_hystory}}",
   "company_mission": "{{company_mission}}",
   "company_services": "{{company_services}}",
   "company_product": "{{company_product}}",
   "use_cookies": "{{use_cookies}}",
   "learn_more": "{{learn_more}}",
   "i_agree": "{{i_agree}}"
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-2024-08-06",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.2,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
    // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
      "title_head", "keywords_head", "description_head", "brand_name", "home_link", "features_link",
      "services_link", "team_link", "contact_link", "about_link", "hero_title_01", "hero_sub_title_text",
      "hero_text", "hero_button", "main_feature_title", "feature_title_01", "feature_text_01", "feature_title_02",
      "feature_text_02", "feature_title_03", "feature_text_03", "about_us", "about_us_text", "services_sub_header",
      "service_header", "service_header_text", "service_title_01", "service_text_01", "service_title_02",
      "service_text_02", "service_title_03", "service_text_03", "benefit_title", "benefits_sub_title", "bennefit_01",
      "benefit_text_01", "benefit_02", "benefit_text_02", "benefit_03", "benefit_text_03", "product_title_01",
      "product_text_01", "our_team_title", "team_member_man_01", "team_role_01", "team_member_man_02", "team_role_02",
      "team_member_woman_01", "team_role_03", "call_to_action_title", "call_to_action_text", "call_to_action_button",
      "testimonial_01", "testimonial_role_01", "testimonial_name_01", "testimonial_02", "testimonial_role_02",
      "testimonial_name_02", "testimonial_03", "testimonial_role_03", "form_title", "form_text", "form_name",
      "form_email", "form_message", "form_button", "call_to_action_footer", "button_footer", "address_footer",
      "services_footer", "product", "about_us", "contact", "tel_num", "call_to_action_footer", "images_key_word",
      "company_hystory", "company_mission", "company_services", "company_product", "use_cookies", "learn_more", "i_agree"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


async function generateKeywordsAndDomain(site_theme, key_words, domain_name, site_language) {
  console.log(' keywords_generated_for_random_whites: ', key_words, domain_name);

  const SYSTEM_PROMPT = `
You are a key-words generating master in creating the most creative, unique, amazing, descriptive, and well-worded key-words and domain-brand names for business website  
 
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${key_words}
 
Your task:
 1. Generate 10 items with 5 key words in each item similar to ${key_words}  on ${site_language} language, for a ${site_theme} business 
 website good for SEO, and response as:  "key_words_001", "key_words_002", "key_words_003", "key_words_004", "key_words_005", "key_words_006", "key_words_007", "key_words_008", "key_words_009",  "key_words_010".
2. Generate different unique 10 domain brand-names based on ${key_words} theme:  ${site_theme} and on English language,  and response as :  "domain_name_001", "domain_name_002", "domain_name_003", "domain_name_004", "domain_name_005", "domain_name_006", "domain_name_007", "domain_name_008", "domain_name_009", "domain_name_010".

### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Do not use any harmful, illegal, unethical, or violent content of any kind in the generating key words and domain name.
3. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
4. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
5. Validate the JSON format before sending the response.
6. Ensure the key-words ad domain brand-name are unique for each generation.
7. Ensure the response have all generated text for all variables: "key_words_001", "domain_name_001".

     

### Example Formatting: Return the content in JSON format
Response only in the follow Example Json format! Example Json:
{

   "key_words_001": {{"key_words_001"}}, 
   "key_words_002": {{"key_words_002"}}, 
   "key_words_003": {{"key_words_003"}}, 
   "key_words_004": {{"key_words_004"}}, 
   "key_words_005": {{"key_words_005"}}, 
   "key_words_006": {{"key_words_006"}}, 
   "key_words_007": {{"key_words_007"}}, 
   "key_words_008": {{"key_words_008"}}, 
   "key_words_009": {{"key_words_009"}}, 
   "key_words_010": {{"key_words_010"}}, 
   "domain_name_001": {{"domain_name_001"}},
   "domain_name_002": {{"domain_name_002"}},
   "domain_name_003": {{"domain_name_003"}},
   "domain_name_004": {{"domain_name_004"}},
   "domain_name_005": {{"domain_name_005"}},
   "domain_name_006": {{"domain_name_006"}},
   "domain_name_007": {{"domain_name_007"}},
   "domain_name_008": {{"domain_name_008"}},
   "domain_name_009": {{"domain_name_009"}},
   "domain_name_010": {{"domain_name_010"}}
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = ["key_words_001", "key_words_002", "key_words_003", "key_words_004", "key_words_005", "key_words_006",
      "key_words_007", "key_words_008", "key_words_009", "key_words_010", "domain_name_001", "domain_name_002", "domain_name_003",
      "domain_name_004", "domain_name_005", "domain_name_006", "domain_name_007", "domain_name_008", "domain_name_009", "domain_name_010"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}

//generate unique blog posts titles
async function generateBlogTitlesFromGPT4o(blog_context, product_context, site_type, site_theme, site_language, keywords_generated_ai, stop_words_ai) {
 // console.log('generateBlogTitlesFromGPT4o keywords_generated_ai: ', keywords_generated_ai);

  const SYSTEM_PROMPT = `
You are an expert website copywriter tasked with generating comprehensive blog content for a business websites, written by your text feels like it's written by a person, not a machine.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${keywords_generated_ai}
- **Site_Language**: ${site_language}
= **Company product**: ${product_context}
= **Blog context**: ${blog_context}
 

### Special Instructions:
- ### General Guidelines:
1. **Token Limit**: The total length of the generated text should not exceed 3500 tokens.
2. **JSON Structure**: The response must be formatted as valid JSON, with all required fields included. Ensure no missing fields.
3. **Clarity**: Use clear, simple language, and ensure all text feels natural and human-like.
- Generate content including:
  - Ensure variation and maximum creativity in sentence structure, vocabulary, and style for each page. Avoid repetition of phrases and concepts across the website.
${stop_words_ai}
### Content Requirements:
Generate engaging unique content in sound more personal and heartfelt maner on ${site_language} laguage the following :

***Generate Blog post short text***: 
   - Generate 3 short unique blog post titles and texts (70 words each) with different styles on ${site_language}, perspectives, and focus points for the ${site_theme} website based on ${blog_context} and ${product_context}, response as:  "blog_title_001"  "blog_text_001"  "blog_title_002"  "blog_text_002"  "blog_title_003"  "blog_text_003".

### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Write a text in a casual and conversational style. 
6. Use shorter sentences and simple language. 
7. Include relatable examples or comparisons to make the information easy to understand. 
8. Make sure all generated text feels like it's written by a person, not a machine. 
8. Ensure maximum uniqueness and creativity in the blog titles and content for each generation.
9. Do not use any harmful, illegal, unethical, or violent content of any kind in generating text.
10. Ensure the response have all generated text for all variables: "blog_title_001", "blog_text_001",
      "blog_title_002", "blog_text_002", "blog_title_003", "blog_text_003" 
     

### Example Formatting: Return the content in JSON format
Response only in the follow Example Json format! Example Json:
{
   "blog_title_001": "{{blog_title_001}}",
   "blog_text_001": "{{blog_text_001}}",
   "blog_title_002": "{{blog_title_002}}",
   "blog_text_002": "{{blog_text_002}}",
   "blog_title_003": "{{blog_title_003}}",
   "blog_text_003": "{{blog_text_003}}"
  
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
    //console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
      "blog_title_001", "blog_text_001", "blog_title_002", "blog_text_002", "blog_title_003", "blog_text_003"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}

 

async function jsonResponseMainKeyWords(site_theme, stop_words_new){
  const SYSTEM_PROMPT = `
You are a SEO key words generating master in creating the most creative, unique, relevant, and well-worded best for SEO key words. You will now take on the role as the number one SEO master in the world. 
Based on website theme: "${site_theme}" , you will then provide the most relevant best for SEO keywords to use in website SEO head meta tag.
 
### Parameters:
- **Site_Theme**: ${site_theme}
 
 
***Generate SEO Key Words***: 
   - Generate 5 SEO keywords represented context website theme:  "${site_theme}", and response as: "key_words".

### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Do not use any harmful, illegal, unethical, or violent content of any kind in generating key words.
3. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
4. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
5. Validate the JSON format before sending the response.
6. Ensure the response have all generated text variable: "key_words"

     

### Example Formatting: Return the content in JSON format
Response only in the follow Example Json format! Example Json:
{

   "key_words": {{"key_words"}}, 
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 400,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponseMainKeyWords = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
      "key_words"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponseMainKeyWords)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponseMainKeyWords;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


//generate prompts for images 
async function generatePromptsFromGPT4oMain( product_context, site_theme, keywords_generated_ai) {
 // console.log('generatePromptsFromGPT4o keywords_generated_ai: ', keywords_generated_ai);

  const SYSTEM_PROMPT = `
You are a prompt-generating master in creating the most creative, unique, amazing, descriptive, and well-worded prompts to create breathtaking, photorealistic images for AI text-to-image tools like Stable Diffusion, Midjourney, and Leonardo AI. You will now take on the role as the number one prompt engineer in the world. Based on my subject, you will then provide the most amazing, realistic, relevant keywords to use to create the most realistic, hyper-realistic, ultra-realistic images possible.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${keywords_generated_ai}
= **Company product**: ${product_context}

 

###Generate Prompts for image generation ai###: 
  - Generate prompt represented visual illustartion for website in context: product: " ${product_context} ", key words: " ${keywords_generated_ai} ",   generate prompt on English language, (avoid using people in prompts, avoid using things with text or logotypes in prompts, avoid using nature scenes ) for a ${site_theme} business website and is as realistic as possible, and response as: "prompt".


### Instructions and Examples ###
1. Be Specific: Crafting specific prompts is key to getting high-quality AI images. 
Example 1: Instead of a general prompt like "A landscape" specify details like "A sunset landscape with vibrant orange and pink hues over a calm ocean."
Example 2:  Instead of a general prompt like "A museum interior" specify details like "A museum interior. The room is spacious with high ceilings and large windows that let in plenty of natural light. The walls are adorned with beautiful, framed paintings and art pieces, each carefully lit by soft, focused lights. The floor is made of polished marble, reflecting the light and giving the space a grand feel."
2. Try to generate the most relevant prompt that will describe the image as closely as possible to the context of the " ${product_context} ", but in the most creative way.
  
### Specific Content Requests:###
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Ensure the response have all generated text for all variables: "prompt".
     

### Example Formatting: Return the content in JSON format:###
Response only in the follow Example Json format! Example Json:
{
   "prompt": {{"prompt"}}
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 1000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
       "prompt"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


//generate prompts for images 
async function generatePromptsFromGPT4o(promptImagesContext, product_context,  site_theme, keywords_generated_ai, promptBlogTitle1 ) {
 // console.log('generatePromptsFromGPT4o keywords_generated_ai: ', keywords_generated_ai);

  const SYSTEM_PROMPT = `
You are a prompt-generating master in creating the most creative, unique, amazing, descriptive, and well-worded prompts to create breathtaking, photorealistic images for AI text-to-image tools like Stable Diffusion, Midjourney, and Leonardo AI. You will now take on the role as the number one prompt engineer in the world. Based on my subject, you will then provide the most amazing, realistic, relevant keywords to use to create the most realistic, hyper-realistic, ultra-realistic images possible.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${keywords_generated_ai}
= **Company product**: ${product_context}
= **Blog context**: ${promptImagesContext}
 

###Generate Prompts for image generation ai###: 
  - Generate prompt represented visual illustartion for blog post in context: blog title: " ${promptBlogTitle1} ", blog post: " ${promptImagesContext} ", generate prompt on English language, (avoid using people in prompts, avoid using things with text or logotypes in prompts, avoid using nature scenes ) for a ${site_theme} business website and is as realistic as possible, and response as: "prompt_1".


### Instructions and Examples ###
1. Be Specific: Crafting specific prompts is key to getting high-quality AI images. 
Example 1: Instead of a general prompt like "A landscape" specify details like "A sunset landscape with vibrant orange and pink hues over a calm ocean."
Example 2:  Instead of a general prompt like "A museum interior" specify details like "A museum interior. The room is spacious with high ceilings and large windows that let in plenty of natural light. The walls are adorned with beautiful, framed paintings and art pieces, each carefully lit by soft, focused lights. The floor is made of polished marble, reflecting the light and giving the space a grand feel."
2. Try to generate the most relevant prompt that will describe the image as closely as possible to the context of the blog, but in the most creative way.
  
### Specific Content Requests:###
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Ensure the response have all generated text for all variables: "prompt_1".
     

### Example Formatting: Return the content in JSON format:###
Response only in the follow Example Json format! Example Json:
{
   "prompt_1": {{"prompt_1"}}
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 1000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
       "prompt_1"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


//generate prompts for images 
async function generatePromptsFromGPT4o2(promptImagesContext2, product_context,  site_theme, keywords_generated_ai, promptBlogTitle2 ) {
  //console.log('generatePromptsFromGPT4o keywords_generated_ai: ', keywords_generated_ai);

  const SYSTEM_PROMPT = `
You are a prompt-generating master in creating the most creative, unique, amazing, descriptive, and well-worded prompts to create breathtaking, photorealistic images for AI text-to-image tools like Stable Diffusion, Midjourney, and Leonardo AI. You will now take on the role as the number one prompt engineer in the world. Based on my subject, you will then provide the most amazing, realistic, relevant keywords to use to create the most realistic, hyper-realistic, ultra-realistic images possible.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${keywords_generated_ai}
= **Company product**: ${product_context}
= **Blog context**: ${promptImagesContext2}
 

###Generate Prompts for image generation ai###: 
  - Generate prompt represented visual illustartion for context: blog title: " ${promptBlogTitle2} ", blog post: " ${promptImagesContext2} ", generate prompt on English language, (avoid using people in prompts, avoid using things with text or logotypes in prompts, avoid using nature scenes ) for a ${site_theme} business website and is as realistic as possible, and response as: "prompt_2".


### Instructions and Examples ###
1. Be Specific: Crafting specific prompts is key to getting high-quality AI images. 
Example 1: Instead of a general prompt like "A landscape" specify details like "A sunset landscape with vibrant orange and pink hues over a calm ocean."
Example 2:  Instead of a general prompt like "A museum interior" specify details like "A museum interior. The room is spacious with high ceilings and large windows that let in plenty of natural light. The walls are adorned with beautiful, framed paintings and art pieces, each carefully lit by soft, focused lights. The floor is made of polished marble, reflecting the light and giving the space a grand feel."
2. Try to generate the most relevant prompt that will describe the image as closely as possible to the context of the blog, but in the most creative way.

### Specific Content Requests:###
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Ensure the response have all generated text for all variables: "prompt_2".
     

### Example Formatting: Return the content in JSON format:###
Response only in the follow Example Json format! Example Json:
{
   "prompt_2": {{"prompt_2"}}
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 1000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
       "prompt_2"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}




//generate prompts for images 
async function generatePromptsFromGPT4o3(promptImagesContext3, product_context,  site_theme, keywords_generated_ai, promptBlogTitle3 ) {
 // console.log('generatePromptsFromGPT4o keywords_generated_ai: ', keywords_generated_ai);

  const SYSTEM_PROMPT = `
You are a prompt-generating master in creating the most creative, unique, amazing, descriptive, and well-worded prompts to create breathtaking, photorealistic images for AI text-to-image tools like Stable Diffusion, Midjourney, and Leonardo AI. You will now take on the role as the number one prompt engineer in the world. Based on my subject, you will then provide the most amazing, realistic, relevant keywords to use to create the most realistic, hyper-realistic, ultra-realistic images possible.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${keywords_generated_ai}
= **Company product**: ${product_context}
= **Blog context**: ${promptImagesContext3}
 

###Generate Prompts for image generation ai###: 
  - Generate prompt represented visual illustartion for context: blog title: " ${promptBlogTitle3} ", blog post: " ${promptImagesContext3} ", generate prompt on English language, (avoid using people in prompts, avoid using things with text or logotypes in prompts, avoid using nature scenes ) for a ${site_theme} business website and is as realistic as possible, and response as: "prompt_3".


### Instructions and Examples ###
1. Be Specific: Crafting specific prompts is key to getting high-quality AI images. 
Example 1: Instead of a general prompt like "A landscape" specify details like "A sunset landscape with vibrant orange and pink hues over a calm ocean."
Example 2:  Instead of a general prompt like "A museum interior" specify details like "A museum interior. The room is spacious with high ceilings and large windows that let in plenty of natural light. The walls are adorned with beautiful, framed paintings and art pieces, each carefully lit by soft, focused lights. The floor is made of polished marble, reflecting the light and giving the space a grand feel."
2. Try to generate the most relevant prompt that will describe the image as closely as possible to the context of the blog, but in the most creative way.

### Specific Content Requests:###
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Ensure the response have all generated text for all variables: "prompt_3".
     

### Example Formatting: Return the content in JSON format:###
Response only in the follow Example Json format! Example Json:
{
   "prompt_3": {{"prompt_3"}}
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 1000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
       "prompt_3"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}

 

 



// Function to replace placeholders with actual data
function replacePlaceholders(template, data) {
  //console.log('Replacing placeholders in the template...');

  let html = template;

  function replaceRecursive(obj, prefix = '') {
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        const placeholder = `{{${prefix}${key}}}`;

        if (typeof value === 'object' && value !== null) {
          replaceRecursive(value, `${prefix}${key}.`);
        } else if (typeof value === 'string') {
          // console.log(`Replacing placeholder ${placeholder} with value: ${value}`);
          html = html.replace(new RegExp(placeholder, 'g'), value);
        } else {
         // console.warn(`Skipping placeholder ${placeholder}: value is not a string, it is ${typeof value}`);
        }
      }
    }
  }

  if (typeof html !== 'string') {
    console.error('Template is not a string:', typeof html);
    throw new TypeError('Template should be a string');
  }

  replaceRecursive(data);

  return html;
}


// Function to load the HTML file, replace placeholders, and print the result
async function generateHTML(template, response) {
  //console.log('generateHTML: Generating HTML from template');
  try {
    // Log the type and content of template
    // console.log('Type of template:', typeof template);
    // console.log('Template content:', template);
    console.log('Template content:', response.blog_slug_001);
    // Log the response object
    // console.log('Response object:', response);

    const generatedHtml = replacePlaceholders(template, response);
    // console.log('Generated HTML function...', generatedHtml);
    return generatedHtml;
  } catch (error) {
    console.error('Error generating HTML:', error);
    throw new Error('Failed to generate HTML');
  }
}

//Ð´ÐµÑˆÐµÐ²Ð°Ñ
async function replicateResponseOld(promptImagesAi) {
  //console.log('promptImagesAi: ', promptImagesAi);

  const input = {
    prompt: promptImagesAi,
    num_outputs: 4,
    negative_prompt: 'deformed fingers, deformed arms, infographic, charts, text++, font++, logo++ illustration, 3d, 2d, painting, cartoons, sketch worst quality, disfigured, ugly, bad, immature, cartoon, anime, 3d, painting, b&w, low quality, Worst quality, Normal quality, Low res, Blurry, Jpeg artifacts, Grainy, extra fingers, Cropped, Out of frame, Out of focus, Bad anatomy, Bad proportions, Deformed, Disconnected limbs, Disfigured, Extra arms, Extra limbs, Extra hands, Fused fingers, Gross proportions, Long neck, Malformed limbs, Mutated, Mutated hands, Mutated limbs, Missing arms, Missing fingers, Poorly drawn hands, Poorly drawn face, extra crus, fused crus, extra thigh, used thigh, poorly drawn face, cloned face, oversized eyes, cartoon, cg, unreal, bad photography, bad photo, aberrations, black and white, collapsed, conjoined, extra windows, harsh lighting, jpeg artifacts, extra windows, multiple levels, photoshop, rotten, oversaturated, twisted, unnatural, unrealistic, 2girl, amputation',
    //disable_safety_checker: true
  };

  try {
    const output = await replicate.run(
      "bytedance/sdxl-lightning-4step:5f24084160c9089501c1b3545d9be3c27883ae2239b6f412990e82d4a6210f8f",
      { input }
    );
   // console.log(output);
    return output;
  } catch (error) {
    console.error('Error running prediction:', error);
    throw error;
  }
}


async function replicateResponse(promptImagesAi) {
  //console.log('promptImagesAi: ', promptImagesAi);

  const input = {
    prompt: promptImagesAi,
    num_outputs: 3,
    negative_prompt: 'deformed fingers, deformed arms, infographic, charts, text++, font++, logo++ illustration, 3d, 2d, painting, cartoons, sketch worst quality, disfigured, ugly, bad, immature, cartoon, anime, 3d, painting, b&w, low quality, Worst quality, Normal quality, Low res, Blurry, Jpeg artifacts, Grainy, extra fingers, Cropped, Out of frame, Out of focus, Bad anatomy, Bad proportions, Deformed, Disconnected limbs, Disfigured, Extra arms, Extra limbs, Extra hands, Fused fingers, Gross proportions, Long neck, Malformed limbs, Mutated, Mutated hands, Mutated limbs, Missing arms, Missing fingers, Poorly drawn hands, Poorly drawn face, extra crus, fused crus, extra thigh, used thigh, poorly drawn face, cloned face, oversized eyes, cartoon, cg, unreal, bad photography, bad photo, aberrations, black and white, collapsed, conjoined, extra windows, harsh lighting, jpeg artifacts, extra windows, multiple levels, photoshop, rotten, oversaturated, twisted, unnatural, unrealistic, 2girl, amputation',
    go_fast: true,
    guidance: 3.5
  };

  try {
    const output = await replicate.run(
      "bytedance/hyper-flux-8step:81946b1e09b256c543b35f37333a30d0d02ee2cd8c4f77cd915873a1ca622bad",
      { input }
    );
   // console.log(output);
    return output;
  } catch (error) {
    console.error('Error running prediction:', error);
    throw error;
  }
}




async function saveHtmlToZip(newIndex, htmlContent, htmlContentServices, htmlContentAbout, htmlContentProduct, generatedHTMLpolicy, generatedHTMLblog, generatedHTMLblog2, generatedHTMLblog3, slug1, slug2, slug3, track_id, imageUrls, imagesAiResponse2, imagesAiResponse3, imagesAiResponseProduct, randomTemplateAssets, generatedHTMLthankyou) {


  return new Promise(async (resolve, reject) => {



    const outputPath = path.join(path.dirname(fileURLToPath(import.meta.url)), `${track_id}.zip`);
    console.log("outputPath:", outputPath)
    const output = fs.createWriteStream(outputPath);
    const archive = archiver('zip', {
      zlib: { level: 9 } // Compression level
    });

    output.on('close', () => {
     // console.log('Archiver has been finalized and the output file descriptor has closed.');
      resolve(outputPath);
    });

    archive.on('error', (err) => {
      reject(err);
    });

    archive.pipe(output);

    // Add HTML files to the ZIP
    archive.append(htmlContent, { name: `${newIndex}.html` });
    archive.append(htmlContentServices, { name: 'services.html' });
    archive.append(htmlContentAbout, { name: 'about.html' });
    archive.append(htmlContentProduct, { name: 'product.html' });
    archive.append(generatedHTMLpolicy, { name: 'policy.html' });
    archive.append(generatedHTMLblog, { name: slug1 + '.html' });
    archive.append(generatedHTMLblog2, { name: slug2 + '.html' });
    archive.append(generatedHTMLblog3, { name: slug3 + '.html' });
    archive.append(generatedHTMLthankyou, { name: 'thankyou.html' });

    // Merge and deduplicate image URLs
    let imagesArray = [...new Set([...imagesAiResponseProduct, ...imageUrls, ...imagesAiResponse2, ...imagesAiResponse3])];

    // Download images and add them to the 'images' folder in the ZIP
    try {
      for (let i = 0; i < imagesArray.length; i++) {
        const imageUrl = imagesArray[i];
        const imageResponse = await axios({
          method: 'GET',
          url: imageUrl,
          responseType: 'arraybuffer'
        });

        const imageFileName = `image${i + 1}.png`;

        // Append image directly to the ZIP under the 'images' folder
        archive.append(imageResponse.data, { name: `images/${imageFileName}` });
      }
    } catch (error) {
      console.error('Error downloading or saving the images:', error);
      reject(error);
      return;
    }

    const assetsPath = path.join(path.dirname(fileURLToPath(import.meta.url)), `./../templates/business/${randomTemplateAssets}/assets/`);
    if (fs.existsSync(assetsPath)) {
      archive.directory(assetsPath, 'assets');
    }

    // Finalize the ZIP file
    archive.finalize();
  });
}

// Connect to MongoDB
const mongoUri = process.env.MONGODB_URL;
await mongoose.connect(mongoUri, { useNewUrlParser: true, useUnifiedTopology: true });

// Initialize Agenda
const agenda = new Agenda({ db: { address: mongoUri, collection: 'jobs' } });

// Start Agenda
await agenda.start();
console.log('Agenda started');

// Define a job to delete a file from S3
agenda.define('delete file', async (job) => {
  const { bucketName, key } = job.attrs.data;
  const params = { Bucket: bucketName, Key: key };

  try {
    await s3.deleteObject(params).promise();
    console.log(`File deleted successfully: ${key}`);
  } catch (error) {
    console.error('Error deleting file:', error);
  }
});

// Function to upload a file to AWS S3
async function uploadToS3(filePath, bucketName, key) {
  const fileContent = fs.readFileSync(filePath);
  const params = { Bucket: bucketName, Key: key, Body: fileContent };

  try {
    const data = await s3.upload(params).promise();
    console.log(`File uploaded successfully at ${data.Location}`);

    // Schedule a job for deleting a file after 1 hour
    await agenda.schedule('in 6 hours', 'delete file', { bucketName, key }); // Test with 1 hour
    console.log('Scheduled deletion in 6 hours');

    return data.Location;
  } catch (error) {
    console.error('Error uploading file:', error);
    throw error;
  }
}

// Graceful Shutdown
process.on('SIGTERM', async () => {
  console.log('Received SIGTERM, shutting down gracefully...');
  await agenda.stop();
  await mongoose.connection.close();
  console.log('Agenda and MongoDB connections closed.');
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('Received SIGINT, shutting down gracefully...');
  await agenda.stop();
  await mongoose.connection.close();
  console.log('Agenda and MongoDB connections closed.');
  process.exit(0);
});




// Graceful Shutdown Function
async function gracefulShutdown(signal) {
  console.log(`Received ${signal}. Shutting down gracefully...`);

  // Stop accepting new connections
  server.close(async () => {
    console.log('Closed out remaining connections.');
    // Stop Agenda from processing jobs
    await agenda.stop();
    console.log('Agenda stopped.');

    // Close the MongoDB connection
    await mongoose.connection.close();
    console.log('MongoDB connection closed.');

    // Exit process
    process.exit(0);
  });
}

// Listen for termination signals
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));


// Function to send data to webhook
async function sendToWebhook(webhookUrl, data) {
  try {
    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      throw new Error(`Failed to send data to webhook: ${response.statusText}`);
    }

    console.log('Data successfully sent to webhook');
  } catch (error) {
    console.error('Error sending data to webhook:', error);
  }
}

function refineKeywords(keywords) {
  // Add logic to refine keywords, e.g., filtering out less relevant terms, combining synonyms, etc.
  // Example: Split keywords and filter out short or common words
  return keywords.split(' ').filter(word => word.length > 3 && !commonWords.includes(word)).join(' ');
}

async function fetchImagesFromUnsplash(keywords, numImages = 8) {
  //console.log(`Fetching images from Unsplash with keywords: ${keywords}`);
  if (!keywords) {
    throw new Error("No keywords provided");
  }

  const keywordList = keywords.split(' ');
  let images = [];

  for (let keyword of keywordList) {
    try {
      const response = await unsplash.search.getPhotos({
        query: keyword,
        orientation: 'landscape',
        page: 1,
        perPage: 10, // Fetch fewer images per query to diversify results
      });

      images = images.concat(response.response.results.map(image => image.urls.regular));

      if (images.length >= numImages) break; // Stop once we have enough images
    } catch (error) {
      console.error(`Error fetching images for keyword "${keyword}":`, error);
    }
  }

  // Ensure we return the exact number of images required
  return images.slice(0, numImages);
}


async function fetchImagesFromPexels(keywords, numImages = 8) {
  console.log(`Fetching images from Pexels with keywords: ${keywords}`);
  if (!keywords) {
    throw new Error("No keywords provided");
  }

  const keywordList = keywords.split(',').map(keyword => keyword.trim());
  let images = [];

  for (let keyword of keywordList) {
    try {
      const response = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent(keyword)}&orientation=landscape&per_page=10`, {
        headers: {
          Authorization: pexelApiKey// Replace with your Pexels API key
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      images = images.concat(data.photos.map(photo => photo.src.large));

      if (images.length >= numImages) break; // Stop once we have enough images
    } catch (error) {
      console.error(`Error fetching images for keyword "${keyword}":`, error);
    }
  }

  // Ensure we return the exact number of images required
  return images.slice(0, numImages);
}

export default fetchImagesFromPexels;


// Function to fetch team member images from local directories
async function fetchTeamMemberImages() {
  const maleImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/male');
  const femaleImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/female');
  const male2ImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/male2');
  const clients1ImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/clients1');
  const clients2ImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/clients2');
  const clients3ImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/clients3');

  const maleImages = fs.readdirSync(maleImagesDir).map(file => path.join('assets/images/faces/male', file));
  const male2Images = fs.readdirSync(male2ImagesDir).map(file => path.join('assets/images/faces/male2', file));
  const femaleImages = fs.readdirSync(femaleImagesDir).map(file => path.join('assets/images/faces/female', file));
  const clients1Images = fs.readdirSync(clients1ImagesDir).map(file => path.join('assets/images/faces/clients1', file));
  const clients2Images = fs.readdirSync(clients2ImagesDir).map(file => path.join('assets/images/faces/clients2', file));
  const clients3Images = fs.readdirSync(clients3ImagesDir).map(file => path.join('assets/images/faces/clients3', file));

  function getRandomImage(images) {
    const randomIndex = Math.floor(Math.random() * images.length);
    return images[randomIndex];
  }

  return {
    image_team_member_man_01: getRandomImage(maleImages),
    image_team_member_man_02: getRandomImage(male2Images),
    image_team_member_woman_01: getRandomImage(femaleImages),
    client_001: getRandomImage(clients1Images),
    client_002: getRandomImage(clients2Images),
    client_003: getRandomImage(clients3Images)
  };
}





function generateSlug(title) {
  // Use transliterateToUrl for non-Latin characters
  return title
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // Remove all non-word characters
    .replace(/\s+/g, '-')     // Replace spaces with dashes
    .replace(/-+/g, '-')
    .replace(/:/g, '');   // Replace multiple dashes with a single dash
}
// Function to transliterate and slugify text
async function transliterateAndSlugifyLatinArabic(title) {
  return slug(title)
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // Remove all non-word characters
    .replace(/\s+/g, '-')     // Replace spaces with dashes
    .replace(/-+/g, '-')
    .replace(/:/g, '');
}


async function processSitesFromSQS(webhook, track_id, site_type, site_theme, site_language, contact_country, file_extension, site_count, rename_index, edit_after_generation, key_words, stop_words, domain_name, site_style = 'minimalist') {
    try {
      sendToClientWithUserId(track_id, 'Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Ð’Ð°Ð¹Ñ‚Ð¿ÐµÐ¹Ð´Ð¶...');
      
      // Ð’Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ñ Ð¸ Ð¿Ð¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ° ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ñ… ÑÐ»Ð¾Ð²
      if (!key_words || key_words === '') {
        const stop_words_directive = stop_words ? 
          `Do not use any of "stop words": ${stop_words}` : 
          `Do not use any harmful, illegal, unethical, or violent content`;
        
        const keywordsResponse = await jsonResponseMainKeyWords(site_theme, stop_words_directive);
        key_words = keywordsResponse.key_words;
      }
      
      // ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð´Ð¾Ð¼ÐµÐ½Ð°
      let brandName = '';
      if (domain_name && domain_name.trim() !== '') {
        let processedDomainName = domain_name.trim();
        if (processedDomainName.startsWith('www.')) {
          processedDomainName = processedDomainName.substring(4);
        }
        const domainParts = processedDomainName.split('.');
        if (domainParts.length > 0 && domainParts[0] !== '') {
          brandName = domainParts[0];
        }
      }
      
      // Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸ ÑÐ°Ð¹Ñ‚Ð°
      const siteConfig = {
        track_id,
        site_type,
        site_theme,
        site_language,
        contact_country,
        file_extension,
        rename_index,
        key_words,
        stop_words,
        domain_name: brandName,
        site_style
      };
      
      // Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ð¿Ñ€Ð¾Ð¼Ð¿Ñ‚Ð° Ð´Ð»Ñ LLM
      const prompt = generatePromptsForHTMLGeneration(site_style, siteConfig);
      
      // Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð½Ñ‹Ð¹ Ð¿Ñ€Ð¾Ð¼Ð¿Ñ‚ Ð´Ð»Ñ LLM
      const systemPrompt = `
  You are an expert web developer and designer specializing in ${site_style} websites.
  Create a complete website in HTML and CSS (embedded in <style> tags).
  The HTML should be valid, responsive, and follow modern web standards.
  Structure your response to clearly separate different pages with comments like:
  <!-- PAGE: index.html -->
  <!-- PAGE: about.html -->
  <!-- PAGE: services.html -->
  etc.
  
  Pay special attention to:
  1. Creating human-like content that doesn't appear AI-generated
  2. Incorporating the keywords naturally for SEO
  3. Making the design responsive for all devices
  4. Ensuring all links between pages work correctly
  5. Including appropriate images placeholders with descriptive alt text
  `;
      
      sendToClientWithUserId(track_id, 'ðŸ–‹ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÐºÐ¾Ð½Ñ‚ÐµÐ½Ñ‚ ÑÐ°Ð¹Ñ‚Ð° Ñ‡ÐµÑ€ÐµÐ· AI...');
      
      // Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ HTML Ñ‡ÐµÑ€ÐµÐ· LLM
      const llmResponse = await generateTextWithLLM({
        prompt,
        systemPrompt
      });
      
      // ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¾Ñ‚Ð²ÐµÑ‚Ð° LLM Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÑÐ°Ð¹Ñ‚Ð°
      const result = await processLLMResponse(llmResponse, siteConfig);
      
      if (result.status === 'error') {
        throw new Error(result.message);
      }
      
      // Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ZIP-Ñ„Ð°Ð¹Ð»Ð° Ð² S3
      const s3BucketName = process.env.AWS_S3_BUCKET_NAME;
      const randomNumber = generateRandom15DigitNumber();
      const s3Key = `${track_id}_${randomNumber}.zip`;
      
      sendToClientWithUserId(track_id, 'ðŸ“¤ Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ Ð³Ð¾Ñ‚Ð¾Ð²Ñ‹Ð¹ ÑÐ°Ð¹Ñ‚...');
      const s3Url = await uploadToS3(result.zipPath, s3BucketName, s3Key);
      
      // ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ
      const webhookUrl = `https://aisitegen.onrender.com/api/v1/generatorTelegram/webhook/?user_id=${encodeURIComponent(track_id)}`;
      await sendToWebhook(webhookUrl, { track_id, s3Url, webhookUrl, status: 'succeeded' });
      
      sendToClientWithUserId(track_id, 'âœ… Ð’Ð°Ð¹Ñ‚Ð¿ÐµÐ¹Ð´Ð¶ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ ÑÐ¾Ð·Ð´Ð°Ð½!');
      
    } catch (error) {
      console.error('Error processing site:', error);
      sendToClientWithUserId(track_id, { status: 'processing_failed', message: error.message });
    }
  }
  
export { sendToClientWithUserId, processSitesFromSQS, addClient, removeClient };

// Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð½Ð¾Ð²ÑƒÑŽ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð´Ð»Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ ÑÐ°Ð¹Ñ‚Ð° Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ LLM
async function generateSiteWithLLM(siteConfig) {
  // ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ ÑÐ°Ð¹Ñ‚Ð°
  const { track_id, site_type, site_theme, site_language, contact_country, 
          key_words, site_style, domain_name } = siteConfig;
  
  // Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð¼Ð¿Ñ‚Ð° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÑÑ‚Ð¸Ð»Ñ ÑÐ°Ð¹Ñ‚Ð°
  const prompt = createPromptByStyle(site_style, siteConfig);
  
  // ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ðº Replicate API
  const siteContent = await replicateLLMRequest(prompt);
  
  // ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÑÐ°Ð¹Ñ‚Ð°
  return processLLMResponse(siteContent, siteConfig);
}
