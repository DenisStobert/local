import * as dotenv from 'dotenv';
import fetch from 'cross-fetch';
import OpenAI from 'openai';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import archiver from 'archiver';
import AWS from 'aws-sdk';
import { createApi } from 'unsplash-js';
import { templateHtml } from './../templates/business/001/template_index.js';
import slug from 'slug';
//import slug from 'limax';
import axios from 'axios';
import Replicate from 'replicate';
import { Agenda } from 'agenda';
import mongoose from 'mongoose';



dotenv.config();

const openaiApiKey = process.env.OPENAI_API_KEY;


const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION || 'us-east-1',
});

const unsplash = createApi({
  accessKey: process.env.UNSPLASH_ACCESS_KEY,
  fetch: fetch,
});

const pexelApiKey = process.env.PEXEL_API_KEY

const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN,
  fetch: fetch,
});


const openai = new OpenAI({
  apiKey: openaiApiKey
});

const clients = new Map(); // Use a Map for better client management

function addClient(client) {
  console.log('addClient: Adding client with track_id:', client.track_id);
  clients.set(client.track_id, client.res);
}

function removeClient(track_id) {
  console.log('removeClient: Removing client with track_id:', track_id);
  if (clients.has(track_id)) {
    const client = clients.get(track_id);
    if (client && client.end) {
      client.end(); // Ensure the response is ended properly
    }
    clients.delete(track_id);
  }
}


async function sendToClientWithUserId(track_id, message) {
 // console.log('sendToClientWithUserId: Preparing to send message to user with user_id:', track_id);

  const payload = {
    user_id: track_id,
    message: message,
  };

 // console.log('Payload to send:', JSON.stringify(payload));

  try {
    const response = await axios.post('https://telegrambotwhitepagegen.onrender.com/notify', payload);
    console.log(`Message sent to user with user_id: ${user_id}, response status: ${response.status}`);
  } catch (error) {
    if (error.response) {
      // Server responded with a status other than 200 range
      console.error('Error response data:', error.response.data);
      console.error('Error response status:', error.response.status);
      console.error('Error response headers:', error.response.headers);
    } else if (error.request) {
      // No response received from server
      console.error('No response received:', error.request);
    } else {
      // Other errors
      console.error('Error sending message with Axios:', error.message);
    }
  }
}



// Function to read random section from HTML files
function getRandomSection(filePath) {
  try {
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const sections = fileContent.match(/<section[^>]*>([\s\S]*?)<\/section>/gi);
    if (sections && sections.length > 0) {
      const randomIndex = Math.floor(Math.random() * sections.length);
      return sections[randomIndex];
    } else {
      throw new Error(`No sections found in ${filePath}`);
    }
  } catch (error) {
    console.error(`Error reading sections from ${filePath}:`, error);
    throw error;
  }
}

// Function to read random section from HTML files
function getRandomPartTop(filePath) {
  try {
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const top = fileContent;
    if (sections && sections.length > 0) {
      const randomIndex = Math.floor(Math.random() * sections.length);
      return sections[randomIndex];
    } else {
      throw new Error(`No sections found in ${filePath}`);
    }
  } catch (error) {
    console.error(`Error reading sections from ${filePath}:`, error);
    throw error;
  }
}

// Function to build PHP template from blocks (Main Page)
function buildPhpTemplate(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ› ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÐšÐ¾Ð´ Ð“Ð»Ð°Ð²Ð½Ð¾Ð¹ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  const topPhpPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topPhp = fs.readFileSync(topPhpPath, 'utf-8');

  const bottomPhpPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomPhp = fs.readFileSync(bottomPhpPath, 'utf-8');

  const categories = [
    'hero', 'features', 'benefits', 'product', 'services', 'aboutus',
    'team', 'blog_php', 'cta', 'testimonial',
    'contact', 'footer_php'
  ];

  let combinedPhp = topPhp;

  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedPhp += section;
    }
  });

  combinedPhp += bottomPhp;
  return combinedPhp.toString();
}

// Function to build PHP services template (Services Page)
function buildPhpTemplateServices(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ› ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ PHP ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹ Ð¡ÐµÑ€Ð²Ð¸ÑÑ‹.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  const topPhpPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topPhp = fs.readFileSync(topPhpPath, 'utf-8');

  const bottomPhpPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomPhp = fs.readFileSync(bottomPhpPath, 'utf-8');

  const categories = ['company_services', 'footer_php'];

  let combinedPhpservices = topPhp;

  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedPhpservices += section;
    }
  });

  combinedPhpservices += bottomPhp;

  return combinedPhpservices.toString();
}

// (Similarly, update other template-building functions to use PHP)

// Function to generate text content using OpenAI GPT models...
// You can keep the GPT-3 specific code here as you had, no changes.


// Function to replace placeholders with PHP variables
function replacePlaceholdersWithPhp(template, data) {
  console.log('Replacing placeholders with PHP variables...');
  let phpTemplate = template;

  Object.keys(data).forEach(key => {
    const searchExp = new RegExp(`{{${key}}}`, 'g');
    const replaceValue = `<?php echo isset($${key}) ? $${key} : ''; ?>`;
    phpTemplate = phpTemplate.replace(searchExp, replaceValue);
  });

  return phpTemplate;
}

// Modify the ZIP creation function to store `.php` files instead of `.html`
async function savePhpToZip(newIndex, htmlContent, htmlContentServices, htmlContentAbout, htmlContentProduct, generatedHTMLpolicy, generatedHTMLblog, generatedHTMLblog2, generatedHTMLblog3, slug1, slug2, slug3, track_id, imageUrls, imagesAiResponse2, imagesAiResponse3, imagesAiResponseProduct, randomTemplateAssets, generatedHTMLthankyou) {
  return new Promise(async (resolve, reject) => {
    const outputPath = path.join(path.dirname(fileURLToPath(import.meta.url)), `${track_id}.zip`);
    const output = fs.createWriteStream(outputPath);
    const archive = archiver('zip', {
      zlib: { level: 9 }  
    });

    output.on('close', () => {
      console.log('Archiver finished, output file descriptor closed.');
      resolve(outputPath);
    });

    archive.on('error', (err) => {
      reject(err);
    });

    archive.pipe(output);
    
    // Add PHP files into the archive
    archive.append(htmlContent, { name: `${newIndex}.php` });
    archive.append(htmlContentServices, { name: 'services.php' });
    archive.append(htmlContentAbout, { name: 'about.php' });
    archive.append(htmlContentProduct, { name: 'product.php' });
    archive.append(generatedHTMLpolicy, { name: 'policy.php' });
    archive.append(generatedHTMLblog, { name: slug1 + '.php' });
    archive.append(generatedHTMLblog2, { name: slug2 + '.php' });
    archive.append(generatedHTMLblog3, { name: slug3 + '.php' });
    archive.append(generatedHTMLthankyou, { name: 'thankyou.php' });
    

    // Add other assets, images, etc.
    // Merge and deduplicate image URLs
    let imagesArray = [...new Set([...imagesAiResponseProduct, ...imageUrls, ...imagesAiResponse2, ...imagesAiResponse3])];

    // Download images and add them to the 'images' folder in the ZIP
    try {
      for (let i = 0; i < imagesArray.length; i++) {
        const imageUrl = imagesArray[i];
        const imageResponse = await axios({
          method: 'GET',
          url: imageUrl,
          responseType: 'arraybuffer'
        });

        const imageFileName = `image${i + 1}.png`;

        // Append image directly to the ZIP under the 'images' folder
        archive.append(imageResponse.data, { name: `images/${imageFileName}` });
      }
    } catch (error) {
      console.error('Error downloading or saving the images:', error);
      reject(error);
      return;
    }

    const assetsPath = path.join(path.dirname(fileURLToPath(import.meta.url)), `./../templates/business/${randomTemplateAssets}/assets/`);
    if (fs.existsSync(assetsPath)) {
      archive.directory(assetsPath, 'assets');
    }

    archive.finalize();
  });
}


// Function to build HTML template from blocks
function buildHtmlTemplate(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ› ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÐšÐ¾Ð´ Ð³Ð»Ð°Ð²Ð½Ð¾Ð¹ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top/top.html`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');
  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom/bottom.html`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');
  const categories = [
    'hero', 'features', 'benefits', 'product', 'services', 'aboutus',
    'team', 'blog', 'cta', 'testimonial',
    'contact', 'footer'
  ];
  // Start building the combined HTML with the top part
  let combinedHtml = topHtml;
  // Iterate over each category and append a random block to the combined HTML
  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtml += section;
    }
  });
  // Append the bottom part to the combined HTML
  combinedHtml += bottomHtml;
  // Return the combined HTML as a string
  return combinedHtml.toString();
}


// service PAGE

// Function to build HTML services template from blocks
function buildHtmlTemplatServices(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ› ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÐšÐ¾Ð´ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹ Ð¡ÐµÑ€Ð²Ð¸ÑÑ‹.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top/top.html`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom/bottom.html`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['company_services', 'footer'];

  let combinedHtmlservices = topHtml;

  // Iterate over each category and append a random block to the combined HTML
  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlservices += section;
    }

  });

  // Append the bottom part to the combined HTML
  combinedHtmlservices += bottomHtml;

  // Return the combined HTML as a string
  return combinedHtmlservices.toString();

}



// Function to build HTML services template from blocks
function buildHtmlTemplatServicesPHP(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ› ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÐšÐ¾Ð´ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹ Ð¡ÐµÑ€Ð²Ð¸ÑÑ‹.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['company_services', 'footer_php'];

  let combinedHtmlservices = topHtml;

  // Iterate over each category and append a random block to the combined HTML
  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlservices += section;
    }

  });

  // Append the bottom part to the combined HTML
  combinedHtmlservices += bottomHtml;

  // Return the combined HTML as a string
  return combinedHtmlservices.toString();

}

async function buildHtmlTemplateThankyou(randomTemplate, track_id) {

  //sendToClientWithUserId(track_id, 'ðŸ”’ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Thank You Page.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top/top.html`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom/bottom.html`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['thankyou', 'footer'];

  // Append the bottom part to the combined HTML
  let combinedHtmlthankyou = topHtml;

  for (const category of categories) {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);


      combinedHtmlthankyou += section;
    }
  }

  combinedHtmlthankyou += bottomHtml;
  return combinedHtmlthankyou;
}

async function buildHtmlTemplateThankyouPHP(randomTemplate, track_id) {

  //sendToClientWithUserId(track_id, 'ðŸ”’ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Thank You Page.');
  sendToClientWithUserId(track_id, 'ðŸ”’ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Thank You Page.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['thankyou', 'footer'];

  // Append the bottom part to the combined HTML
  let combinedHtmlthankyouPHP = topHtml;

  for (const category of categories) {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);


      combinedHtmlthankyouPHP += section;
    }
  }

  combinedHtmlthankyouPHP += bottomHtml;
  return combinedHtmlthankyouPHP;
}

async function buildHtmlTemplatePolicy(site_language, randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ”’ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Privacy Policy.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top/top.html`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom/bottom.html`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['policy', 'footer'];

  // Append the bottom part to the combined HTML
  let combinedHtmlpolicy = topHtml;

  for (const category of categories) {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      const sectionPolicy = await translatedTextPolicyFromGPT4omini(section, site_language); // Await the translation

      combinedHtmlpolicy += sectionPolicy;
    }
  }

  combinedHtmlpolicy += bottomHtml;
  return combinedHtmlpolicy;
}


async function buildHtmlTemplatePolicyPHP(site_language, randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ”’ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Privacy Policy.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['policy', 'footer_php'];

  // Append the bottom part to the combined HTML
  let combinedHtmlpolicy = topHtml;

  for (const category of categories) {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      const sectionPolicy = await translatedTextPolicyFromGPT4omini(section, site_language); // Await the translation

      combinedHtmlpolicy += sectionPolicy;
    }
  }

  combinedHtmlpolicy += bottomHtml;
  return combinedHtmlpolicy;
}


// Function to build HTML template from blocks
function buildHtmlTemplatAbout(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ¢ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñƒ Ðž ÐšÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top/top.html`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom/bottom.html`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['company_about', "team", 'footer'];

  let combinedHtmlabout = topHtml;

  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlabout += section;
    }

  });

  combinedHtmlabout += bottomHtml;
  return combinedHtmlabout;
}


// Function to build HTML template from blocks
function buildHtmlTemplatAboutPHP(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ¢ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñƒ Ðž ÐšÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['company_about', "team", 'footer_php'];

  let combinedHtmlabout = topHtml;

  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlabout += section;
    }

  });

  combinedHtmlabout += bottomHtml;
  return combinedHtmlabout;
}

// Function to build HTML template from blocks
function buildHtmlTemplateProduct(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ› ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÐšÐ¾Ð´ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹ ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top/top.html`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom/bottom.html`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['company_product', 'services', 'contact', 'footer'];

  let combinedHtmlproduct = topHtml

  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlproduct += section;
    }

  });

  combinedHtmlproduct += bottomHtml;

  return combinedHtmlproduct;
}


// Function to build HTML template from blocks
function buildHtmlTemplateProductPHP(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ› ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÐšÐ¾Ð´ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹ ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['company_product', 'services', 'contact', 'footer_php'];

  let combinedHtmlproduct = topHtml

  categories.forEach(category => {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlproduct += section;
    }

  });

  combinedHtmlproduct += bottomHtml;

  return combinedHtmlproduct;
}



async function buildHtmlTemplateBlog(randomTemplate, track_id) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top/top.html`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom/bottom.html`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['blog_page', 'blog', 'footer'];

  let combinedHtmlblog = topHtml;

  for (const category of categories) {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlblog += section;
    }
  }

  combinedHtmlblog += bottomHtml;

  return combinedHtmlblog;
}



async function buildHtmlTemplateBlog2(randomTemplate, track_id) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top/top.html`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom/bottom.html`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['blog_page_2', 'blog', 'footer'];

  let combinedHtmlblog2 = topHtml;

  for (const category of categories) {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlblog2 += section;
    }
  }

  combinedHtmlblog2 += bottomHtml;

  return combinedHtmlblog2;
}


async function buildHtmlTemplateBlog3(randomTemplate, track_id) {
  sendToClientWithUserId(track_id, 'ðŸ› ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÐšÐ¾Ð´ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ† Ð‘Ð»Ð¾Ð³Ð°.');
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top/top.html`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom/bottom.html`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');
  const categories = ['blog_page_3', 'blog', 'footer'];



  let combinedHtmlblog3 = topHtml;

  for (const category of categories) {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlblog3 += section;
    }
  }

  combinedHtmlblog3 += bottomHtml;

  return combinedHtmlblog3;
}



// php blogs
async function buildPHPTemplateBlog(randomTemplate, track_id) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['blog_page', 'blog_php', 'footer_php'];

  let combinedHtmlblog = topHtml;

  for (const category of categories) {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlblog += section;
    }
  }

  combinedHtmlblog += bottomHtml;

  return combinedHtmlblog;
}


// php blogs
async function buildPHPTemplateBlog2(randomTemplate, track_id) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['blog_page_2', 'blog_php', 'footer_php'];

  let combinedHtmlblog = topHtml;

  for (const category of categories) {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlblog += section;
    }
  }

  combinedHtmlblog += bottomHtml;

  return combinedHtmlblog;
}


// php blogs
async function buildPHPTemplateBlog3(randomTemplate, track_id) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  // Read the top part of the HTML template
  const topHtmlPath = path.join(__dirname, `../${randomTemplate}/top_php/top.php`);
  const topHtml = fs.readFileSync(topHtmlPath, 'utf-8');

  // Read the bottom part of the HTML template
  const bottomHtmlPath = path.join(__dirname, `../${randomTemplate}/bottom_php/bottom.php`);
  const bottomHtml = fs.readFileSync(bottomHtmlPath, 'utf-8');

  const categories = ['blog_page_3', 'blog_php', 'footer_php'];

  let combinedHtmlblog = topHtml;

  for (const category of categories) {
    const categoryPath = path.join(__dirname, `../${randomTemplate}/${category}`);
    const files = fs.readdirSync(categoryPath);
    if (files.length > 0) {
      const randomFile = files[Math.floor(Math.random() * files.length)];
      const filePath = path.join(categoryPath, randomFile);
      const section = getRandomSection(filePath);
      combinedHtmlblog += section;
    }
  }

  combinedHtmlblog += bottomHtml;

  return combinedHtmlblog;
}


//

// Function to generate text content using OpenAI GPT-4
async function translatedTextFromGPT4o(key_words, site_language) {
  console.log('translateTextFromGPT4');

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "user", content: `Translate and refine keywords "${key_words}" for image searching relevance in ${site_language} respose only key words splitted with ',' do not respose any comments, response 5 key words` }
      ],
      temperature: 0.2,
      max_tokens: 400,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    const translatedText = response.choices[0].message.content.trim();
    console.log('GPT4 response ok: Translated Text');

    //return refineKeywords(translatedText); // Use the refinement function
    return translatedText;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Failed to translate text using OpenAI');
  }
}



// Function to generate text content using OpenAI GPT-4
async function translatedThankYouFromGPT4o(site_language) {
  console.log('translateTextFromGPT4');

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "user", content: `
        1. Translate text "Thank you for subscribing!" to "${site_language}" response only translated text in JSON format
        as "thank_you" 
        2. Translate text "We're excited to have you on board! Stay tuned for the latest updates, tips, and exclusive content delivered right to your inbox." to "${site_language}" response only translated text in JSON format
        as "thank_you_text".
        ### Example Formatting: Return the content in JSON format structured as follows example:
Response only in the follow Example Json format! Example Json:
{
  "thank_you": "{{thank_you}}",
  "thank_you_text": "{{thank_you_text}}"
}
        ` }
      ],
      temperature: 0.2,
      max_tokens: 1000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    const translatedText = response.choices[0].message.content.trim();
   // console.log('GPT4 response ok: Translated Text');
    const generatedTextThankYou = translatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponseThankyou = JSON.parse(generatedTextThankYou);

    //return refineKeywords(translatedText); // Use the refinement function
    return jsonResponseThankyou;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Failed to translate text using OpenAI');
  }
}

 

// Function to generate text content using OpenAI GPT-4
async function transliterateAndSlugify(title) {
 // console.log('transliterateAndSlugify');

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "user", content: `Translitarate to english and refine keywords "${title}"  and response as human readable url, response only translitarated words without your comments` }
      ],
      temperature: 0.2,
      max_tokens: 400,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    const transliterateText = response.choices[0].message.content.trim();
   // console.log('GPT4 response ok: Translated Text');

    //return refineKeywords(translatedText); // Use the refinement function
    return transliterateText;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Failed to translate text using OpenAI');
  }
}


async function translatedTextPolicyFromGPT4omini(policy, site_language) {
  console.log('start translatedTextPolicyFromGPT4omini');

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "user", content: `Translate to ${site_language} text inside html, do not change html, do not translate html classes names ad data-attibutes, do not translate or remove {{brand_name}}, response in html format only, text in html to translate:  "${policy}" ` }
      ],
      temperature: 0.2,
      max_tokens: 3000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let translatedTextPolicy = response.choices[0].message.content.trim();
   // console.log('GPT4 response ok: Translated Text');
    // console.log(translatedTextPolicy);

    // Remove any surrounding ```html and ``` markdown syntax
    translatedTextPolicy = translatedTextPolicy.replace(/```html/g, '').replace(/```/g, '').trim();

    return translatedTextPolicy;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Failed to translate text using OpenAI');
  }
}

function generateSlugNew(title) {
  return title
    .toLowerCase()
    .replace(/\s+/g, '-')     // Replace spaces with dashes
    .replace(/-+/g, '-')
    .replace(/:/g, '');     // Replace multiple dashes with a single dash
}

async function generateTextBlogFromGPT4o(site_type, site_theme, site_language, contact_country, key_words, promptBlogTitle1, promptBlogShortText1) {
  console.log('generateTextBlogFromGPT4');

  const SYSTEM_PROMPT = `
You are an expert website copywriter tasked with generating comprehensive blog post content for a ${site_theme} website. 

The website will serve as a robust digital presence for the company, effectively communicating its mission, services, and products to potential customers. 
Based on 
### Parameters:
- **Site_Theme**: ${site_theme}
- **Site_Type**: ${site_type}
- **Keywords**: ${key_words}
- **Site_Language**: ${site_language}
- **contact_country**: ${contact_country}
- **Blog Post Title**: ${promptBlogTitle1}, 
- **Blog Post Short Text**: ${promptBlogShortText1}

### Special Instructions:
- Each paragraph should have 200-300 words of text. 
- Generate text for blog post about 2000-2300 words
- Generate content including:
  - include in text key words: "${key_words}" and use it to generate persuasive text blog post. Use 4-5 ${key_words} in text according to context.
### Content Requirements:
Generate engaging content in ${site_language}:
### Pages and Sections:

1. **Blog Title**: generate a blog post text around around 3000 words with sub-headers and 5 paragraphs and wrap sub-headers in html tag <h4> and wrap paragraphs in html tag <p>,  generate blog text on language: "${site_language}", based on ${promptBlogTitle1} and "${promptBlogShortText1}" and keywords: "${key_words}", ${site_theme} and in response as "text_blog".
   
### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Do not use any prohibited words or themes, jargon or themes as NSFW, do not use any politics topics.
3. Ensure the response is in valid JSON format.
4. Do not include backticks or single quotes in the response.
5. Validate the JSON format before sending the response.
6. Ensure the response has all generated text for all variables: "title_blog", "short_text_blog", "text_blog".
7. Make sure blog post text is around 2000 words.
8. Write a text in a casual and conversational style. 
9. Use shorter sentences and simple language. 
10. Include relatable examples or comparisons to make the information easy to understand. 
11. Make sure it feels like it's written by a person, not a machine.
12. Wrap sub-headers in HTML tag <h4> and wrap paragraphs in HTML tag <p>.

### Example Formatting: Return the content in JSON format structured as follows example:
Response only in the follow Example Json format! Example Json:
{
  "title_blog": "${promptBlogTitle1}",
  "short_text_blog": "${promptBlogShortText1}",
  "text_blog": "{{text_blog}}"
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.4,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Blog1 Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponseBlog = JSON.parse(generatedText);
 

    // Check if all required fields are present
    const requiredFields = ["title_blog", "short_text_blog", "text_blog"];

    for (const field of requiredFields) {
      if (!(field in jsonResponseBlog)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponseBlog;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


async function generateTextBlog2FromGPT4o(site_type, site_theme, site_language, contact_country, key_words, promptBlogTitle2, promptBlogShortText2) {
  console.log('generateTextBlogFromGPT4 2');

  const SYSTEM_PROMPT = `
You are an expert website copywriter tasked with generating comprehensive blog post content for a ${site_theme} website. 
The website will serve as a robust digital presence for the company, effectively communicating its mission, services, and products to potential customers. 
Based on 
### Parameters:
- **Site_Theme**: ${site_theme}
- **Site_Type**: ${site_type}
- **Keywords**: ${key_words}
- **Site_Language**: ${site_language}
- **contact_country**: ${contact_country}
- **Blog Post Title**: ${promptBlogTitle2}, 
- **Blog Post Short Text**: ${promptBlogShortText2}

### Special Instructions:
- Each paragraph should have 200-300 words of text. 
- Generate text for blog post about 2000-2300 words
- Generate content including:
  - include in text key words: "${key_words}" and use it to generate persuasive text blog post. Use 4-5 ${key_words} in text according to context.
### Content Requirements:
Generate engaging content in ${site_language}:
### Pages and Sections:

1. **Blog Title**: generate a blog post text around around 3000 words with sub-headers and 5 paragraphs and wrap sub-headers in html tag <h4> and wrap paragraphs in html tag <p>,  generate blog text on language: "${site_language}", based on ${promptBlogTitle2} and "${promptBlogShortText2}" and keywords: "${key_words}", ${site_theme} and in response as "text_blog_2".
   
### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Do not use any prohibited words or themes, jargon or themes as NSFW, do not use any politics topics.
3. Ensure the response is in valid JSON format.
4. Do not include backticks or single quotes in the response.
5. Validate the JSON format before sending the response.
6. Ensure the response has all generated text for all variables: : "title_blog_2", "short_text_blog_2", "text_blog_2".
7. Make sure blog post text is around 2000 words.
8. Write a text in a casual and conversational style. 
9. Use shorter sentences and simple language. 
10. Include relatable examples or comparisons to make the information easy to understand. 
11. Make sure it feels like it's written by a person, not a machine. 
12. Wrap sub-headers in HTML tag <h4> and wrap paragraphs in HTML tag <p>.


### Example Formatting: Return the content in JSON format structured as follows example:
Response only in the follow Example Json format! Example Json:
{
  "title_blog_2": "${promptBlogTitle2}",
  "short_text_blog_2": "${promptBlogShortText2}",
  "text_blog_2": "{{text_blog_2}}"
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.4,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Blog1 Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponseBlog2 = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = ["title_blog_2", "short_text_blog_2", "text_blog_2"];

    for (const field of requiredFields) {
      if (!(field in jsonResponseBlog2)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponseBlog2;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


async function generateTextBlog3FromGPT4o(site_type, site_theme, site_language, contact_country, key_words, promptBlogTitle3, promptBlogShortText3) {
 // console.log('generateTextBlogFromGPT4');


  const SYSTEM_PROMPT = `
You are an expert website copywriter tasked with generating comprehensive blog post content for a ${site_theme} website. 
The website will serve as a robust digital presence for the company, effectively communicating its mission, services, and products to potential customers. 
Based on 
### Parameters:
- **Site_Theme**: ${site_theme}
- **Site_Type**: ${site_type}
- **Keywords**: ${key_words}
- **Site_Language**: ${site_language}
- **contact_country**: ${contact_country}
- **Blog Post Title**: ${promptBlogTitle3}, 
- **Blog Post Short Text**: ${promptBlogShortText3}

### Special Instructions:
- Each paragraph should have 200-300 words of text. 
- Generate text for blog post about 2000-2300 words
- Generate content including:
  - include in text key words: "${key_words}" and use it to generate persuasive text blog post. Use 4-5 ${key_words} in text according to context.
### Content Requirements:
Generate engaging content in ${site_language}:
### Pages and Sections:

1. **Blog Title**: generate a blog post text around 3000 words with sub-headers and 5 paragraphs and wrap sub-headers in html tag <h4> and wrap paragraphs in html tag <p>,  generate blog text on language: "${site_language}", based on ${promptBlogTitle3} and "${promptBlogShortText3}" and keywords: "${key_words}", ${site_theme} and in response as "text_blog_2".
   
### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Do not use any prohibited words or themes, jargon or themes as NSFW, do not use any politics topics.
3. Ensure the response is in valid JSON format.
4. Do not include backticks or single quotes in the response.
5. Validate the JSON format before sending the response.
6. Ensure the response has all generated text for all variables: "title_blog_3", "short_text_blog_3", "text_blog_3".
7. Make sure blog post text is around 2000 words.
8. Write a text in a casual and conversational style. 
9. Use shorter sentences and simple language. 
10. Include relatable examples or comparisons to make the information easy to understand. 
11. Make sure it feels like it's written by a person, not a machine. 
12. Wrap sub-headers in HTML tag <h4> and wrap paragraphs in HTML tag <p>


### Example Formatting: Return the content in JSON format structured as follows example:
Response only in the follow Example Json format! Example Json:
{
  "title_blog_3": "${promptBlogTitle3}",
  "short_text_blog_3": "${promptBlogShortText3}",
  "text_blog_3": "{{text_blog_3}}"
}
`;

  //console.log('SYSTEM_PROMPT:  ', SYSTEM_PROMPT)
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.4,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    let generatedText = response.choices[0].message.content;
    //console.log('GPT4 response ok: Generated Blog1 Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponseBlog3 = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = ["title_blog_3", "short_text_blog_3", "text_blog_3"];

    for (const field of requiredFields) {
      if (!(field in jsonResponseBlog3)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponseBlog3;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}

// Function to generate text content using OpenAI GPT-4
async function generateTextFromGPT4o(site_type, site_theme, site_language, contact_country, key_words, domain_to_ai, brandName, stop_words_ai, track_id) {
 // console.log('generateTextFromGPT4');


  const SYSTEM_PROMPT = `
You are an expert website copywriter tasked with generating comprehensive content for a business websites, written by your text feels like it's written by a person, not a machine.
The website will serve as a robust digital presence for the company, effectively communicating its mission, services, and products to potential customers.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Site_Type**: ${site_type}
- **Key_words**: ${key_words}
- **Site_Language**: ${site_language}
- **contact_country**: ${contact_country}
- **domain_name**: ${brandName}

### Special Instructions:
- ### General Guidelines:
1. **Token Limit**: The total length of the generated text should not exceed 3500 tokens.
2. **JSON Structure**: The response must be formatted as valid JSON, with all required fields included. Ensure no missing fields.
3. **Clarity**: Use clear, simple language, and ensure all text feels natural and human-like.
4. **Content Structure**: Focus on generating content for each page in sequence. Ensure each section is complete before moving on to the next.
- Each paragraph should have 30-40 words of text.
- Generate text for all 5 pages in your response - Home, About us, Contacts, Services, Products
- Generate content including:
  - A brand name for the business that aligns with the ${site_theme}.
  - Value Proposition based on ${site_theme} and use it to generate persuasive text copy About us page. 
  - Ensure variation and creativity in sentence structure, vocabulary, and style for each page. Avoid repetition of phrases and concepts across the website.
${stop_words_ai}
### Content Requirements:
Generate engaging unique content in sound more personal and heartfelt maner on ${site_language} laguage the following pages:
### Pages and Sections:

1. **Index Page**:
   - **Sections**:
      1. Hero Section:
      ${domain_to_ai}
      - Create an engaging header title "hero_title_01"  , generate meta title ad response as "title_head", generate sub-title "hero_sub_title_text", generate paragraph "hero_text" about 100 words emphasizing the title with a value proposition for the brand name of the company based on ${key_words} for the ${site_theme} website. Generate text one word for Hero button and response as "hero_button"
      2. **Features**: write a list of features based on value proposition 
      - write on ${site_language} word "Features" and use it as "main_feature_title" in response.
      - Write 3 feature titles with features explained text: "feature_title_01", "feature_text_01", "feature_title_02", "feature_text_02", "feature_title_03", "feature_text_03"
      3. **About the Business**: Provide an overview of the business. 
      - write on ${site_language} words "About us" and use it as "about_us" in response.
      - write text about us text "about_us_text" based ${key_words} and use it to generate persuasive text copy About us text for company.
      4. **Services**: Highlight the key services offered.
      - services title write on ${site_language} words "Services" and use it as "service_header" in response.
      - write a services sub-header and use it as "services_sub_header" in response.
      - write a service text and use it as "service_header_text" in response.
      - write a 3 Services title and short paragraph text for each and use it as: "service_title_01", "service_text_01",  "service_title_02", "service_text_02",  "service_title_03", "service_text_03"  
      5. **Benefits**: Highlight 3 key benefits offered.
      - benefits title  write on ${site_language} words "Benefits" and use it as "benefit_title" in response.
      - write a benefits sub-title and use it as "benefits_sub_title" in response.
      - write a 3 benefits title and short paragraph text for each benefit and use it as: "bennefit_01", "benefit_text_01",  "benefit_02", "benefit_text_02",  "benefit_03", "benefit_text_03" 
      6. **Product** Describe product based on value proposition.
      - write product title and use it as "product_title_01" in response.
      - write product text 300 words and use it as "product_text_01" in response.
      7. **Team Information**: Introduce the team members and their roles.
           - team title write on ${site_language} words "Our team" and use it as "our_team_title" in response.
           - write 3 team person names and roles(based on business type ${site_theme} best for small and medium company size) use names and sur-names according to ${contact_country} 2 man and 1 woman and use it in response as: "team_member_man_01", "team_role_01", "team_member_man_02", "team_role_02", "team_member_woman_01", "team_role_03"
     8. **Contact**: Generate a concise footer text with contact information, Generate a real office address for a business in the capital city of ${contact_country}. The address should include a street name, building number, real zip code, and any additional details that make it appear authentic. Ensure the address and zip code is plausible within the context of capital of ${contact_country} and response as: "address_footer", and a random telephone number with the ${contact_country} country prefix.
     9. ***Navigation**: Translate navbar links text to ${site_language}  and use it as links in response: "Home" response as "home_link", "Features"  response as "features_link", "Services" response as "services_link", "Our Team" response as "team_link", "Contact" response as "contact_link", "About Us" response as "about_link".
     10. **Call-to-action**: Generate Call to action text base on Value Proposion and ${key_words} and button text and response as "call_to_action_title", geenrate call to action short text response as "call_to_action_text", generate call-to-action button text and response as "call_to_action_button", generate call-to-action button text and response as "button_footer".
     11. **Translate Form**: title and placeholders: Generate short engaging text for form response as "form_text", Translate "Send Us A Message" response as "form_title", "Message" response as "form_message", "Your Name" response as "form_name", "Your Email" response as "form_email", "Your Message" resposne as "form_message".
     12. **Site Meta**: Generate text for meta description response as "description_head", 
     13. ***Key Words*: Generate 7 key-words for SEO close in context for initial key words: "${key_words}" but all unique and different and response as "keywords_head".
     14. ***Testimonials*: Generate short Users Testimonials  reflected value proposition and enthusiastic tone and response all as: 
      - "Testimonial text 1" response as "testimonial_*" all testimonials - "testimonial_01" as testimonial_01, "Testimonial person business role" as "testimonial_role_01",  testimonial name as "testimonial_name_01,  use female name and sur-name according to ${contact_country} and use it in response as "testimonial_name_01,  
      - "Testimonial text 2" as "testimonial_02", "Testimonial person business role" as "testimonial_role_02", use male name and sur-name according to ${contact_country} testimoial 2 name as "testimonial_name_02", "Testimonial text 3" as "testimonial_03", "Testimonial person business role" as "testimonial_role_03", use male name and sur-name according to ${contact_country} testimonial 3 name and response as "testimonial_name_03".
     15. ***Footer*: Generate call to action title response as "call_to_action_footer", Translate text to ${site_language} "Services" response as "services_footer" , Translate "Product" response as "product", Translate "Contact Us" response as "contact".
     16.***Translate text***: Translate baner text: "We use cookies to ensure you get the best experience on our website." to ${site_language} and use in response as: "use_cookies". 
     17. Translate to ${site_language} words "Learn more" and use in response as: "learn_more". 
     18. Translate to ${site_language} word "Close" and use in response as: "i_agree".

    
2. **About Us Page**:
   - **Company History**: Describe the history of the company about 300 words response as "company_hystory"
   - **Mission and Values**: Outline the company's mission and core values about 200 words and response as "company_mission"
3. **Services Page**:
   - **Service Descriptions**: Offer detailed descriptions of the main services provided by the business about 500 word and response as "company_services"
4. **Products Page**:
   - **Products Descriptions**: describe the primary products offered by the business about 400 words ad response as "company_product".
5. **Contact Us Page**:
   - **Contact Details**: Provide comprehensive contact information, including location.
   - **Contact Form**: Include a user-friendly contact form for inquiries.
6. ***Traslate Key word to English***: Translate ${key_words} to English: and response as: "images_key_word".


### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Write a text in a casual and conversational style. 
6. Use shorter sentences and simple language. 
7. Include relatable examples or comparisons to make the information easy to understand. 
8. Make sure all generated text feels like it's written by a person, not a machine. 
9. Ensure uniqueness and creativity in the blog titles and content for each generation.
10. Do not use any harmful, illegal, unethical, or violent content of any kind in the generating text.
11. Ensure the response have all generated text for all variables: "title_head", "keywords_head", "description_head", "brand_name", "home_link", "features_link",
      "services_link", "team_link", "contact_link", "about_link", "hero_title_01", "hero_sub_title_text",
      "hero_text", "hero_button", "main_feature_title", "feature_title_01", "feature_text_01", "feature_title_02",
      "feature_text_02", "feature_title_03", "feature_text_03", "about_us", "about_us_text", "services_sub_header",
      "service_header", "service_header_text", "service_title_01", "service_text_01", "service_title_02",
      "service_text_02", "service_title_03", "service_text_03", "benefit_title", "benefits_sub_title", "bennefit_01",
      "benefit_text_01", "benefit_02", "benefit_text_02", "benefit_03", "benefit_text_03", "product_title_01",
      "product_text_01", "our_team_title", "team_member_man_01", "team_role_01", "team_member_man_02", "team_role_02",
      "team_member_woman_01", "team_role_03", "call_to_action_title", "call_to_action_text", "call_to_action_button",
      "testimonial_01", "testimonial_role_01", "testimonial_name_01", "testimonial_02", "testimonial_role_02",
      "testimonial_name_02", "testimonial_03", "testimonial_role_03", "form_title", "form_text", "form_name",
      "form_email", "form_message", "form_button", "call_to_action_footer", "button_footer", "address_footer",
      "services_footer", "product", "about_us", "contact", "tel_num", "call_to_action_footer", "images_key_word",
      "company_hystory", "company_mission", "company_services", "company_product", "use_cookies", "learn_more", "i_agree"
     

### Example Formatting: Return the content in JSON format for each 5 pages - index, about, services, products, contact, structured as follows example minimum 2000 symbols for every page maximum 7000 words for all pages:
Response only in the follow Example Json format! Example Json:
{
  "title_head": "{{title_head}}",
  "keywords_head": "{{keywords_head}}",
  "description_head": "{{description_head}}",
  "brand_name": "{{brand_name}}",
  "home_link": "{{home_link}}",
  "features_link": "{{features_link}}",
  "services_link": "{{services_link}}", 
  "team_link": "{{team_link}}", 
  "contact_link": "{{contact_link}}", 
  "about_link": "{{about_link}}",
  "hero_title_01": "{{hero_title_01}}:",
  "hero_sub_title_text": "{{hero_sub_title_text}}",
  "hero_text": "{{hero_text}}",
  "hero_button": "{{hero_button}}",
  "main_feature_title": "{{main_feature_title}}",
  "feature_title_01": "{{feature_title_01}}",
  "feature_text_01": "{{feature_text_01}}",
  "feature_title_02": "{{feature_title_02}}",
  "feature_text_02": "{{feature_text_02}}",
  "feature_title_03": "{{feature_title_03}}",
  "feature_text_03": "{{feature_text_03}}",
  "about_us": "{{about_us}}",
  "about_us_text": "{{about_us_text}}",
  "services_sub_header": "{{services_sub_header}}",
  "service_header": "{{service_header}}",
  "service_header_text": "{{service_header_text}}",
  "service_title_01": "{{service_title_01}}",
  "service_text_01": "{{service_text_01}}",
  "service_title_02": "{{service_title_02}}",
  "service_text_02": "{{service_text_02}}",
  "service_title_03": "{{service_title_03}}",
  "service_text_03": "{{service_text_03}}",
  "benefit_title": "{{benefit_title}}",
  "benefits_sub_title": "{{benefits_sub_title}}",
  "bennefit_01": "{{bennefit_01}}",
  "benefit_text_01": "{{benefit_text_01}}",
  "benefit_02": "{{benefit_02}}",
  "benefit_text_02": "{{benefit_text_02}}",
  "benefit_03": "{{benefit_03}}",
  "benefit_text_03": {"benefit_text_03}}",
  "product_title_01": "{{product_title_01}}",
  "product_text_01": "{{product_text_01}}",
  "our_team_title": "{{our_team_title}}",
  "team_member_man_01": "{{team_member_man_01}}",
  "team_role_01": "{{team_role_01}}",
  "team_member_man_02": "{{team_member_man_02}}",
  "team_role_02": "{{team_role_02}}",
  "team_member_woman_01": "{{team_member_woman_01}}",
  "team_role_03": "{{team_role_03}}",
  "call_to_action_title": "{{call_to_action_title}}",
  "call_to_action_text": "{{call_to_action_text}}",
  "call_to_action_button": "{{call_to_action_button}}",
  "testimonial_01": "{{testimonial_01}}",
  "testimonial_role_01": "{{testimonial_role_01}}",
  "testimonial_name_01": "{{testimonial_name_01}}",
  "testimonial_02": "{{testimonial_02}}",
  "testimonial_role_02": "{{testimonial_role_02}}",
  "testimonial_name_02": "{{testimonial_name_02}}",
  "testimonial_03": "{{testimonial_03}}",
  "testimonial_role_03": {{"testimonial_role_03}}",
  "form_title": "{{form_title}}",
  "form_text": "{{form_text}}",
  "form_name": "{{form_name}}",
  "form_email": "{{form_email}}",
  "form_message": "{{form_message}}",
  "form_button": "{{form_button}}",
  "call_to_action_footer": "{{call_to_action_footer}}",
  "button_footer": "{{button_footer}}",
  "address_footer": "{{address_footer}}",
  "services_footer": "{{services_footer}}",
  "product": "{{product}}",
  "about_us": "{{about_us}}",
  "contact": "{{contact}}",
  "tel_num": "{{tel_num}}"
  "call_to_action_footer": "{{call_to_action_footer}}",
    "images_key_word": "{{images_key_word}}",
    "company_hystory": "{{company_hystory}}",
   "company_mission": "{{company_mission}}",
   "company_services": "{{company_services}}",
   "company_product": "{{company_product}}",
   "use_cookies": "{{use_cookies}}",
   "learn_more": "{{learn_more}}",
   "i_agree": "{{i_agree}}"
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-2024-08-06",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.2,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
    // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
      "title_head", "keywords_head", "description_head", "brand_name", "home_link", "features_link",
      "services_link", "team_link", "contact_link", "about_link", "hero_title_01", "hero_sub_title_text",
      "hero_text", "hero_button", "main_feature_title", "feature_title_01", "feature_text_01", "feature_title_02",
      "feature_text_02", "feature_title_03", "feature_text_03", "about_us", "about_us_text", "services_sub_header",
      "service_header", "service_header_text", "service_title_01", "service_text_01", "service_title_02",
      "service_text_02", "service_title_03", "service_text_03", "benefit_title", "benefits_sub_title", "bennefit_01",
      "benefit_text_01", "benefit_02", "benefit_text_02", "benefit_03", "benefit_text_03", "product_title_01",
      "product_text_01", "our_team_title", "team_member_man_01", "team_role_01", "team_member_man_02", "team_role_02",
      "team_member_woman_01", "team_role_03", "call_to_action_title", "call_to_action_text", "call_to_action_button",
      "testimonial_01", "testimonial_role_01", "testimonial_name_01", "testimonial_02", "testimonial_role_02",
      "testimonial_name_02", "testimonial_03", "testimonial_role_03", "form_title", "form_text", "form_name",
      "form_email", "form_message", "form_button", "call_to_action_footer", "button_footer", "address_footer",
      "services_footer", "product", "about_us", "contact", "tel_num", "call_to_action_footer", "images_key_word",
      "company_hystory", "company_mission", "company_services", "company_product", "use_cookies", "learn_more", "i_agree"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


async function generateKeywordsAndDomain(site_theme, key_words, domain_name, site_language) {
  console.log(' keywords_generated_for_random_whites: ', key_words, domain_name);

  const SYSTEM_PROMPT = `
You are a key-words generating master in creating the most creative, unique, amazing, descriptive, and well-worded key-words and domain-brand names for business website  
 
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${key_words}
 
Your task:
 1. Generate 10 items with 5 key words in each item similar to ${key_words}  on ${site_language} language, for a ${site_theme} business 
 website good for SEO, and response as:  "key_words_001", "key_words_002", "key_words_003", "key_words_004", "key_words_005", "key_words_006", "key_words_007", "key_words_008", "key_words_009",  "key_words_010".
2. Generate different unique 10 domain brand-names based on ${key_words} theme:  ${site_theme} and on English language,  and response as :  "domain_name_001", "domain_name_002", "domain_name_003", "domain_name_004", "domain_name_005", "domain_name_006", "domain_name_007", "domain_name_008", "domain_name_009", "domain_name_010".

### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Do not use any harmful, illegal, unethical, or violent content of any kind in the generating key words and domain name.
3. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
4. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
5. Validate the JSON format before sending the response.
6. Ensure the key-words ad domain brand-name are unique for each generation.
7. Ensure the response have all generated text for all variables: "key_words_001", "domain_name_001".

     

### Example Formatting: Return the content in JSON format
Response only in the follow Example Json format! Example Json:
{

   "key_words_001": {{"key_words_001"}}, 
   "key_words_002": {{"key_words_002"}}, 
   "key_words_003": {{"key_words_003"}}, 
   "key_words_004": {{"key_words_004"}}, 
   "key_words_005": {{"key_words_005"}}, 
   "key_words_006": {{"key_words_006"}}, 
   "key_words_007": {{"key_words_007"}}, 
   "key_words_008": {{"key_words_008"}}, 
   "key_words_009": {{"key_words_009"}}, 
   "key_words_010": {{"key_words_010"}}, 
   "domain_name_001": {{"domain_name_001"}},
   "domain_name_002": {{"domain_name_002"}},
   "domain_name_003": {{"domain_name_003"}},
   "domain_name_004": {{"domain_name_004"}},
   "domain_name_005": {{"domain_name_005"}},
   "domain_name_006": {{"domain_name_006"}},
   "domain_name_007": {{"domain_name_007"}},
   "domain_name_008": {{"domain_name_008"}},
   "domain_name_009": {{"domain_name_009"}},
   "domain_name_010": {{"domain_name_010"}}
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = ["key_words_001", "key_words_002", "key_words_003", "key_words_004", "key_words_005", "key_words_006",
      "key_words_007", "key_words_008", "key_words_009", "key_words_010", "domain_name_001", "domain_name_002", "domain_name_003",
      "domain_name_004", "domain_name_005", "domain_name_006", "domain_name_007", "domain_name_008", "domain_name_009", "domain_name_010"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}

//generate unique blog posts titles
async function generateBlogTitlesFromGPT4o(blog_context, product_context, site_type, site_theme, site_language, keywords_generated_ai, stop_words_ai) {
 // console.log('generateBlogTitlesFromGPT4o keywords_generated_ai: ', keywords_generated_ai);

  const SYSTEM_PROMPT = `
You are an expert website copywriter tasked with generating comprehensive blog content for a business websites, written by your text feels like it's written by a person, not a machine.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${keywords_generated_ai}
- **Site_Language**: ${site_language}
= **Company product**: ${product_context}
= **Blog context**: ${blog_context}
 

### Special Instructions:
- ### General Guidelines:
1. **Token Limit**: The total length of the generated text should not exceed 3500 tokens.
2. **JSON Structure**: The response must be formatted as valid JSON, with all required fields included. Ensure no missing fields.
3. **Clarity**: Use clear, simple language, and ensure all text feels natural and human-like.
- Generate content including:
  - Ensure variation and maximum creativity in sentence structure, vocabulary, and style for each page. Avoid repetition of phrases and concepts across the website.
${stop_words_ai}
### Content Requirements:
Generate engaging unique content in sound more personal and heartfelt maner on ${site_language} laguage the following :

***Generate Blog post short text***: 
   - Generate 3 short unique blog post titles and texts (70 words each) with different styles on ${site_language}, perspectives, and focus points for the ${site_theme} website based on ${blog_context} and ${product_context}, response as:  "blog_title_001"  "blog_text_001"  "blog_title_002"  "blog_text_002"  "blog_title_003"  "blog_text_003".

### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Write a text in a casual and conversational style. 
6. Use shorter sentences and simple language. 
7. Include relatable examples or comparisons to make the information easy to understand. 
8. Make sure all generated text feels like it's written by a person, not a machine. 
8. Ensure maximum uniqueness and creativity in the blog titles and content for each generation.
9. Do not use any harmful, illegal, unethical, or violent content of any kind in generating text.
10. Ensure the response have all generated text for all variables: "blog_title_001", "blog_text_001",
      "blog_title_002", "blog_text_002", "blog_title_003", "blog_text_003" 
     

### Example Formatting: Return the content in JSON format
Response only in the follow Example Json format! Example Json:
{
   "blog_title_001": "{{blog_title_001}}",
   "blog_text_001": "{{blog_text_001}}",
   "blog_title_002": "{{blog_title_002}}",
   "blog_text_002": "{{blog_text_002}}",
   "blog_title_003": "{{blog_title_003}}",
   "blog_text_003": "{{blog_text_003}}"
  
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 4095,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
    //console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
      "blog_title_001", "blog_text_001", "blog_title_002", "blog_text_002", "blog_title_003", "blog_text_003"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}

 

async function jsonResponseMainKeyWords(site_theme, stop_words_new){
  const SYSTEM_PROMPT = `
You are a SEO key words generating master in creating the most creative, unique, relevant, and well-worded best for SEO key words. You will now take on the role as the number one SEO master in the world. 
Based on website theme: "${site_theme}" , you will then provide the most relevant best for SEO keywords to use in website SEO head meta tag.
 
### Parameters:
- **Site_Theme**: ${site_theme}
 
 
***Generate SEO Key Words***: 
   - Generate 5 SEO keywords represented context website theme:  "${site_theme}", and response as: "key_words".

### Specific Content Requests:
1. Remove any off-topic and extraneous text from the generated response.
2. Do not use any harmful, illegal, unethical, or violent content of any kind in generating key words.
3. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
4. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
5. Validate the JSON format before sending the response.
6. Ensure the response have all generated text variable: "key_words"

     

### Example Formatting: Return the content in JSON format
Response only in the follow Example Json format! Example Json:
{

   "key_words": {{"key_words"}}, 
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 400,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponseMainKeyWords = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
      "key_words"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponseMainKeyWords)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponseMainKeyWords;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


//generate prompts for images 
async function generatePromptsFromGPT4oMain( product_context, site_theme, keywords_generated_ai) {
 // console.log('generatePromptsFromGPT4o keywords_generated_ai: ', keywords_generated_ai);

  const SYSTEM_PROMPT = `
You are a prompt-generating master in creating the most creative, unique, amazing, descriptive, and well-worded prompts to create breathtaking, photorealistic images for AI text-to-image tools like Stable Diffusion, Midjourney, and Leonardo AI. You will now take on the role as the number one prompt engineer in the world. Based on my subject, you will then provide the most amazing, realistic, relevant keywords to use to create the most realistic, hyper-realistic, ultra-realistic images possible.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${keywords_generated_ai}
= **Company product**: ${product_context}

 

###Generate Prompts for image generation ai###: 
  - Generate prompt represented visual illustartion for website in context: product: " ${product_context} ", key words: " ${keywords_generated_ai} ",   generate prompt on English language, (avoid using people in prompts, avoid using things with text or logotypes in prompts, avoid using nature scenes ) for a ${site_theme} business website and is as realistic as possible, and response as: "prompt".


### Instructions and Examples ###
1. Be Specific: Crafting specific prompts is key to getting high-quality AI images. 
Example 1: Instead of a general prompt like "A landscape" specify details like "A sunset landscape with vibrant orange and pink hues over a calm ocean."
Example 2:  Instead of a general prompt like "A museum interior" specify details like "A museum interior. The room is spacious with high ceilings and large windows that let in plenty of natural light. The walls are adorned with beautiful, framed paintings and art pieces, each carefully lit by soft, focused lights. The floor is made of polished marble, reflecting the light and giving the space a grand feel."
2. Try to generate the most relevant prompt that will describe the image as closely as possible to the context of the " ${product_context} ", but in the most creative way.
  
### Specific Content Requests:###
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Ensure the response have all generated text for all variables: "prompt".
     

### Example Formatting: Return the content in JSON format:###
Response only in the follow Example Json format! Example Json:
{
   "prompt": {{"prompt"}}
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 1000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
       "prompt"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


//generate prompts for images 
async function generatePromptsFromGPT4o(promptImagesContext, product_context,  site_theme, keywords_generated_ai, promptBlogTitle1 ) {
 // console.log('generatePromptsFromGPT4o keywords_generated_ai: ', keywords_generated_ai);

  const SYSTEM_PROMPT = `
You are a prompt-generating master in creating the most creative, unique, amazing, descriptive, and well-worded prompts to create breathtaking, photorealistic images for AI text-to-image tools like Stable Diffusion, Midjourney, and Leonardo AI. You will now take on the role as the number one prompt engineer in the world. Based on my subject, you will then provide the most amazing, realistic, relevant keywords to use to create the most realistic, hyper-realistic, ultra-realistic images possible.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${keywords_generated_ai}
= **Company product**: ${product_context}
= **Blog context**: ${promptImagesContext}
 

###Generate Prompts for image generation ai###: 
  - Generate prompt represented visual illustartion for blog post in context: blog title: " ${promptBlogTitle1} ", blog post: " ${promptImagesContext} ", generate prompt on English language, (avoid using people in prompts, avoid using things with text or logotypes in prompts, avoid using nature scenes ) for a ${site_theme} business website and is as realistic as possible, and response as: "prompt_1".


### Instructions and Examples ###
1. Be Specific: Crafting specific prompts is key to getting high-quality AI images. 
Example 1: Instead of a general prompt like "A landscape" specify details like "A sunset landscape with vibrant orange and pink hues over a calm ocean."
Example 2:  Instead of a general prompt like "A museum interior" specify details like "A museum interior. The room is spacious with high ceilings and large windows that let in plenty of natural light. The walls are adorned with beautiful, framed paintings and art pieces, each carefully lit by soft, focused lights. The floor is made of polished marble, reflecting the light and giving the space a grand feel."
2. Try to generate the most relevant prompt that will describe the image as closely as possible to the context of the blog, but in the most creative way.
  
### Specific Content Requests:###
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Ensure the response have all generated text for all variables: "prompt_1".
     

### Example Formatting: Return the content in JSON format:###
Response only in the follow Example Json format! Example Json:
{
   "prompt_1": {{"prompt_1"}}
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 1000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
       "prompt_1"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}


//generate prompts for images 
async function generatePromptsFromGPT4o2(promptImagesContext2, product_context,  site_theme, keywords_generated_ai, promptBlogTitle2 ) {
  //console.log('generatePromptsFromGPT4o keywords_generated_ai: ', keywords_generated_ai);

  const SYSTEM_PROMPT = `
You are a prompt-generating master in creating the most creative, unique, amazing, descriptive, and well-worded prompts to create breathtaking, photorealistic images for AI text-to-image tools like Stable Diffusion, Midjourney, and Leonardo AI. You will now take on the role as the number one prompt engineer in the world. Based on my subject, you will then provide the most amazing, realistic, relevant keywords to use to create the most realistic, hyper-realistic, ultra-realistic images possible.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${keywords_generated_ai}
= **Company product**: ${product_context}
= **Blog context**: ${promptImagesContext2}
 

###Generate Prompts for image generation ai###: 
  - Generate prompt represented visual illustartion for context: blog title: " ${promptBlogTitle2} ", blog post: " ${promptImagesContext2} ", generate prompt on English language, (avoid using people in prompts, avoid using things with text or logotypes in prompts, avoid using nature scenes ) for a ${site_theme} business website and is as realistic as possible, and response as: "prompt_2".


### Instructions and Examples ###
1. Be Specific: Crafting specific prompts is key to getting high-quality AI images. 
Example 1: Instead of a general prompt like "A landscape" specify details like "A sunset landscape with vibrant orange and pink hues over a calm ocean."
Example 2:  Instead of a general prompt like "A museum interior" specify details like "A museum interior. The room is spacious with high ceilings and large windows that let in plenty of natural light. The walls are adorned with beautiful, framed paintings and art pieces, each carefully lit by soft, focused lights. The floor is made of polished marble, reflecting the light and giving the space a grand feel."
2. Try to generate the most relevant prompt that will describe the image as closely as possible to the context of the blog, but in the most creative way.

### Specific Content Requests:###
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Ensure the response have all generated text for all variables: "prompt_2".
     

### Example Formatting: Return the content in JSON format:###
Response only in the follow Example Json format! Example Json:
{
   "prompt_2": {{"prompt_2"}}
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 1000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
       "prompt_2"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}




//generate prompts for images 
async function generatePromptsFromGPT4o3(promptImagesContext3, product_context,  site_theme, keywords_generated_ai, promptBlogTitle3 ) {
 // console.log('generatePromptsFromGPT4o keywords_generated_ai: ', keywords_generated_ai);

  const SYSTEM_PROMPT = `
You are a prompt-generating master in creating the most creative, unique, amazing, descriptive, and well-worded prompts to create breathtaking, photorealistic images for AI text-to-image tools like Stable Diffusion, Midjourney, and Leonardo AI. You will now take on the role as the number one prompt engineer in the world. Based on my subject, you will then provide the most amazing, realistic, relevant keywords to use to create the most realistic, hyper-realistic, ultra-realistic images possible.
### Parameters:
- **Site_Theme**: ${site_theme}
- **Keywords**: ${keywords_generated_ai}
= **Company product**: ${product_context}
= **Blog context**: ${promptImagesContext3}
 

###Generate Prompts for image generation ai###: 
  - Generate prompt represented visual illustartion for context: blog title: " ${promptBlogTitle3} ", blog post: " ${promptImagesContext3} ", generate prompt on English language, (avoid using people in prompts, avoid using things with text or logotypes in prompts, avoid using nature scenes ) for a ${site_theme} business website and is as realistic as possible, and response as: "prompt_3".


### Instructions and Examples ###
1. Be Specific: Crafting specific prompts is key to getting high-quality AI images. 
Example 1: Instead of a general prompt like "A landscape" specify details like "A sunset landscape with vibrant orange and pink hues over a calm ocean."
Example 2:  Instead of a general prompt like "A museum interior" specify details like "A museum interior. The room is spacious with high ceilings and large windows that let in plenty of natural light. The walls are adorned with beautiful, framed paintings and art pieces, each carefully lit by soft, focused lights. The floor is made of polished marble, reflecting the light and giving the space a grand feel."
2. Try to generate the most relevant prompt that will describe the image as closely as possible to the context of the blog, but in the most creative way.

### Specific Content Requests:###
1. Remove any off-topic and extraneous text from the generated response.
2. Ensure the response is in valid JSON format.  Remove from the response any Unexpected tokens in JSON. 
3. Do not include backticks or single quotes in the response. Remove ay Unexpected strings symbols in JSON response.
4. Validate the JSON format before sending the response.
5. Ensure the response have all generated text for all variables: "prompt_3".
     

### Example Formatting: Return the content in JSON format:###
Response only in the follow Example Json format! Example Json:
{
   "prompt_3": {{"prompt_3"}}
}
`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: '' }
      ],
      temperature: 0.7,
      max_tokens: 1000,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: { type: "json_object" }
    });

    if (!response.choices || response.choices.length === 0) {
      throw new Error('Failed to generate text using OpenAI');
    }

    let generatedText = response.choices[0].message.content;
   // console.log('GPT4 response ok: Generated Text HTML' + generatedText);

    // Remove any extraneous backticks or markdown code blocks
    generatedText = generatedText.replace(/```json/g, '').replace(/```/g, '').trim();

    // Validate and parse JSON response
    const jsonResponse = JSON.parse(generatedText);

    // Check if all required fields are present
    const requiredFields = [
       "prompt_3"
    ];

    for (const field of requiredFields) {
      if (!(field in jsonResponse)) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    return jsonResponse;
  } catch (error) {
    console.error('Error generating text using OpenAI:', error);
    throw new Error('Invalid JSON response from OpenAI');
  }
}

 

 



// Function to replace placeholders with actual data
function replacePlaceholders(template, data) {
  //console.log('Replacing placeholders in the template...');

  let html = template;

  function replaceRecursive(obj, prefix = '') {
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        const placeholder = `{{${prefix}${key}}}`;

        if (typeof value === 'object' && value !== null) {
          replaceRecursive(value, `${prefix}${key}.`);
        } else if (typeof value === 'string') {
          // console.log(`Replacing placeholder ${placeholder} with value: ${value}`);
          html = html.replace(new RegExp(placeholder, 'g'), value);
        } else {
         // console.warn(`Skipping placeholder ${placeholder}: value is not a string, it is ${typeof value}`);
        }
      }
    }
  }

  if (typeof html !== 'string') {
    console.error('Template is not a string:', typeof html);
    throw new TypeError('Template should be a string');
  }

  replaceRecursive(data);

  return html;
}


// Function to load the HTML file, replace placeholders, and print the result
async function generateHTML(template, response) {
  //console.log('generateHTML: Generating HTML from template');
  try {
    // Log the type and content of template
    // console.log('Type of template:', typeof template);
    // console.log('Template content:', template);
    console.log('Template content:', response.blog_slug_001);
    // Log the response object
    // console.log('Response object:', response);

    const generatedHtml = replacePlaceholders(template, response);
    // console.log('Generated HTML function...', generatedHtml);
    return generatedHtml;
  } catch (error) {
    console.error('Error generating HTML:', error);
    throw new Error('Failed to generate HTML');
  }
}

//Ð´ÐµÑˆÐµÐ²Ð°Ñ
async function replicateResponseOld(promptImagesAi) {
  //console.log('promptImagesAi: ', promptImagesAi);

  const input = {
    prompt: promptImagesAi,
    num_outputs: 4,
    negative_prompt: 'deformed fingers, deformed arms, infographic, charts, text++, font++, logo++ illustration, 3d, 2d, painting, cartoons, sketch worst quality, disfigured, ugly, bad, immature, cartoon, anime, 3d, painting, b&w, low quality, Worst quality, Normal quality, Low res, Blurry, Jpeg artifacts, Grainy, extra fingers, Cropped, Out of frame, Out of focus, Bad anatomy, Bad proportions, Deformed, Disconnected limbs, Disfigured, Extra arms, Extra limbs, Extra hands, Fused fingers, Gross proportions, Long neck, Malformed limbs, Mutated, Mutated hands, Mutated limbs, Missing arms, Missing fingers, Poorly drawn hands, Poorly drawn face, extra crus, fused crus, extra thigh, used thigh, poorly drawn face, cloned face, oversized eyes, cartoon, cg, unreal, bad photography, bad photo, aberrations, black and white, collapsed, conjoined, extra windows, harsh lighting, jpeg artifacts, extra windows, multiple levels, photoshop, rotten, oversaturated, twisted, unnatural, unrealistic, 2girl, amputation',
    //disable_safety_checker: true
  };

  try {
    const output = await replicate.run(
      "bytedance/sdxl-lightning-4step:5f24084160c9089501c1b3545d9be3c27883ae2239b6f412990e82d4a6210f8f",
      { input }
    );
   // console.log(output);
    return output;
  } catch (error) {
    console.error('Error running prediction:', error);
    throw error;
  }
}


async function replicateResponse(promptImagesAi) {
  //console.log('promptImagesAi: ', promptImagesAi);

  const input = {
    prompt: promptImagesAi,
    num_outputs: 3,
    negative_prompt: 'deformed fingers, deformed arms, infographic, charts, text++, font++, logo++ illustration, 3d, 2d, painting, cartoons, sketch worst quality, disfigured, ugly, bad, immature, cartoon, anime, 3d, painting, b&w, low quality, Worst quality, Normal quality, Low res, Blurry, Jpeg artifacts, Grainy, extra fingers, Cropped, Out of frame, Out of focus, Bad anatomy, Bad proportions, Deformed, Disconnected limbs, Disfigured, Extra arms, Extra limbs, Extra hands, Fused fingers, Gross proportions, Long neck, Malformed limbs, Mutated, Mutated hands, Mutated limbs, Missing arms, Missing fingers, Poorly drawn hands, Poorly drawn face, extra crus, fused crus, extra thigh, used thigh, poorly drawn face, cloned face, oversized eyes, cartoon, cg, unreal, bad photography, bad photo, aberrations, black and white, collapsed, conjoined, extra windows, harsh lighting, jpeg artifacts, extra windows, multiple levels, photoshop, rotten, oversaturated, twisted, unnatural, unrealistic, 2girl, amputation',
    go_fast: true,
    guidance: 3.5
  };

  try {
    const output = await replicate.run(
      "bytedance/hyper-flux-8step:81946b1e09b256c543b35f37333a30d0d02ee2cd8c4f77cd915873a1ca622bad",
      { input }
    );
   // console.log(output);
    return output;
  } catch (error) {
    console.error('Error running prediction:', error);
    throw error;
  }
}




async function saveHtmlToZip(newIndex, htmlContent, htmlContentServices, htmlContentAbout, htmlContentProduct, generatedHTMLpolicy, generatedHTMLblog, generatedHTMLblog2, generatedHTMLblog3, slug1, slug2, slug3, track_id, imageUrls, imagesAiResponse2, imagesAiResponse3, imagesAiResponseProduct, randomTemplateAssets, generatedHTMLthankyou) {


  return new Promise(async (resolve, reject) => {



    const outputPath = path.join(path.dirname(fileURLToPath(import.meta.url)), `${track_id}.zip`);
    console.log("outputPath:", outputPath)
    const output = fs.createWriteStream(outputPath);
    const archive = archiver('zip', {
      zlib: { level: 9 } // Compression level
    });

    output.on('close', () => {
     // console.log('Archiver has been finalized and the output file descriptor has closed.');
      resolve(outputPath);
    });

    archive.on('error', (err) => {
      reject(err);
    });

    archive.pipe(output);

    // Add HTML files to the ZIP
    archive.append(htmlContent, { name: `${newIndex}.html` });
    archive.append(htmlContentServices, { name: 'services.html' });
    archive.append(htmlContentAbout, { name: 'about.html' });
    archive.append(htmlContentProduct, { name: 'product.html' });
    archive.append(generatedHTMLpolicy, { name: 'policy.html' });
    archive.append(generatedHTMLblog, { name: slug1 + '.html' });
    archive.append(generatedHTMLblog2, { name: slug2 + '.html' });
    archive.append(generatedHTMLblog3, { name: slug3 + '.html' });
    archive.append(generatedHTMLthankyou, { name: 'thankyou.html' });

    // Merge and deduplicate image URLs
    let imagesArray = [...new Set([...imagesAiResponseProduct, ...imageUrls, ...imagesAiResponse2, ...imagesAiResponse3])];

    // Download images and add them to the 'images' folder in the ZIP
    try {
      for (let i = 0; i < imagesArray.length; i++) {
        const imageUrl = imagesArray[i];
        const imageResponse = await axios({
          method: 'GET',
          url: imageUrl,
          responseType: 'arraybuffer'
        });

        const imageFileName = `image${i + 1}.png`;

        // Append image directly to the ZIP under the 'images' folder
        archive.append(imageResponse.data, { name: `images/${imageFileName}` });
      }
    } catch (error) {
      console.error('Error downloading or saving the images:', error);
      reject(error);
      return;
    }

    const assetsPath = path.join(path.dirname(fileURLToPath(import.meta.url)), `./../templates/business/${randomTemplateAssets}/assets/`);
    if (fs.existsSync(assetsPath)) {
      archive.directory(assetsPath, 'assets');
    }

    // Finalize the ZIP file
    archive.finalize();
  });
}

// Connect to MongoDB
const mongoUri = process.env.MONGODB_URL;
await mongoose.connect(mongoUri, { useNewUrlParser: true, useUnifiedTopology: true });

// Initialize Agenda
const agenda = new Agenda({ db: { address: mongoUri, collection: 'jobs' } });

// Start Agenda
await agenda.start();
console.log('Agenda started');

// Define a job to delete a file from S3
agenda.define('delete file', async (job) => {
  const { bucketName, key } = job.attrs.data;
  const params = { Bucket: bucketName, Key: key };

  try {
    await s3.deleteObject(params).promise();
    console.log(`File deleted successfully: ${key}`);
  } catch (error) {
    console.error('Error deleting file:', error);
  }
});

// Function to upload a file to AWS S3
async function uploadToS3(filePath, bucketName, key) {
  const fileContent = fs.readFileSync(filePath);
  const params = { Bucket: bucketName, Key: key, Body: fileContent };

  try {
    const data = await s3.upload(params).promise();
    console.log(`File uploaded successfully at ${data.Location}`);

    // Schedule a job for deleting a file after 1 hour
    await agenda.schedule('in 6 hours', 'delete file', { bucketName, key }); // Test with 1 hour
    console.log('Scheduled deletion in 6 hours');

    return data.Location;
  } catch (error) {
    console.error('Error uploading file:', error);
    throw error;
  }
}

// Graceful Shutdown
process.on('SIGTERM', async () => {
  console.log('Received SIGTERM, shutting down gracefully...');
  await agenda.stop();
  await mongoose.connection.close();
  console.log('Agenda and MongoDB connections closed.');
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('Received SIGINT, shutting down gracefully...');
  await agenda.stop();
  await mongoose.connection.close();
  console.log('Agenda and MongoDB connections closed.');
  process.exit(0);
});




// Graceful Shutdown Function
async function gracefulShutdown(signal) {
  console.log(`Received ${signal}. Shutting down gracefully...`);

  // Stop accepting new connections
  server.close(async () => {
    console.log('Closed out remaining connections.');
    // Stop Agenda from processing jobs
    await agenda.stop();
    console.log('Agenda stopped.');

    // Close the MongoDB connection
    await mongoose.connection.close();
    console.log('MongoDB connection closed.');

    // Exit process
    process.exit(0);
  });
}

// Listen for termination signals
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));


// Function to send data to webhook
async function sendToWebhook(webhookUrl, data) {
  try {
    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      throw new Error(`Failed to send data to webhook: ${response.statusText}`);
    }

    console.log('Data successfully sent to webhook');
  } catch (error) {
    console.error('Error sending data to webhook:', error);
  }
}

function refineKeywords(keywords) {
  // Add logic to refine keywords, e.g., filtering out less relevant terms, combining synonyms, etc.
  // Example: Split keywords and filter out short or common words
  return keywords.split(' ').filter(word => word.length > 3 && !commonWords.includes(word)).join(' ');
}

async function fetchImagesFromUnsplash(keywords, numImages = 8) {
  //console.log(`Fetching images from Unsplash with keywords: ${keywords}`);
  if (!keywords) {
    throw new Error("No keywords provided");
  }

  const keywordList = keywords.split(' ');
  let images = [];

  for (let keyword of keywordList) {
    try {
      const response = await unsplash.search.getPhotos({
        query: keyword,
        orientation: 'landscape',
        page: 1,
        perPage: 10, // Fetch fewer images per query to diversify results
      });

      images = images.concat(response.response.results.map(image => image.urls.regular));

      if (images.length >= numImages) break; // Stop once we have enough images
    } catch (error) {
      console.error(`Error fetching images for keyword "${keyword}":`, error);
    }
  }

  // Ensure we return the exact number of images required
  return images.slice(0, numImages);
}


async function fetchImagesFromPexels(keywords, numImages = 8) {
  console.log(`Fetching images from Pexels with keywords: ${keywords}`);
  if (!keywords) {
    throw new Error("No keywords provided");
  }

  const keywordList = keywords.split(',').map(keyword => keyword.trim());
  let images = [];

  for (let keyword of keywordList) {
    try {
      const response = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent(keyword)}&orientation=landscape&per_page=10`, {
        headers: {
          Authorization: pexelApiKey// Replace with your Pexels API key
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      images = images.concat(data.photos.map(photo => photo.src.large));

      if (images.length >= numImages) break; // Stop once we have enough images
    } catch (error) {
      console.error(`Error fetching images for keyword "${keyword}":`, error);
    }
  }

  // Ensure we return the exact number of images required
  return images.slice(0, numImages);
}

export default fetchImagesFromPexels;


// Function to fetch team member images from local directories
async function fetchTeamMemberImages() {
  const maleImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/male');
  const femaleImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/female');
  const male2ImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/male2');
  const clients1ImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/clients1');
  const clients2ImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/clients2');
  const clients3ImagesDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '../assets/images/faces/clients3');

  const maleImages = fs.readdirSync(maleImagesDir).map(file => path.join('assets/images/faces/male', file));
  const male2Images = fs.readdirSync(male2ImagesDir).map(file => path.join('assets/images/faces/male2', file));
  const femaleImages = fs.readdirSync(femaleImagesDir).map(file => path.join('assets/images/faces/female', file));
  const clients1Images = fs.readdirSync(clients1ImagesDir).map(file => path.join('assets/images/faces/clients1', file));
  const clients2Images = fs.readdirSync(clients2ImagesDir).map(file => path.join('assets/images/faces/clients2', file));
  const clients3Images = fs.readdirSync(clients3ImagesDir).map(file => path.join('assets/images/faces/clients3', file));

  function getRandomImage(images) {
    const randomIndex = Math.floor(Math.random() * images.length);
    return images[randomIndex];
  }

  return {
    image_team_member_man_01: getRandomImage(maleImages),
    image_team_member_man_02: getRandomImage(male2Images),
    image_team_member_woman_01: getRandomImage(femaleImages),
    client_001: getRandomImage(clients1Images),
    client_002: getRandomImage(clients2Images),
    client_003: getRandomImage(clients3Images)
  };
}





function generateSlug(title) {
  // Use transliterateToUrl for non-Latin characters
  return title
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // Remove all non-word characters
    .replace(/\s+/g, '-')     // Replace spaces with dashes
    .replace(/-+/g, '-')
    .replace(/:/g, '');   // Replace multiple dashes with a single dash
}
// Function to transliterate and slugify text
async function transliterateAndSlugifyLatinArabic(title) {
  return slug(title)
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // Remove all non-word characters
    .replace(/\s+/g, '-')     // Replace spaces with dashes
    .replace(/-+/g, '-')
    .replace(/:/g, '');
}


async function processSitesFromSQS(webhook, track_id, site_type, site_theme, site_language, contact_country, file_extension, site_count, rename_index, edit_after_generation, key_words, stop_words, domain_name) {

  console.log('domain_name: ', domain_name)

  sendToClientWithUserId(track_id, 'Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Ð’Ð°Ð¹Ñ‚Ð¿ÐµÐ¹Ð´Ð¶...');
 

  function getLangAttr(site_language) {
    const languageCodes = {
      'ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹': 'en',
      'Ð˜ÑÐ¿Ð°Ð½ÑÐºÐ¸Ð¹': 'es',
      'Ð¤Ñ€Ð°Ð½Ñ†ÑƒÐ·ÑÐºÐ¸Ð¹': 'fr',
      'ÐÐµÐ¼ÐµÑ†ÐºÐ¸Ð¹': 'de',
      'Ð˜Ñ‚Ð°Ð»ÑŒÑÐ½ÑÐºÐ¸Ð¹': 'it',
      'ÐŸÐ¾Ñ€Ñ‚ÑƒÐ³Ð°Ð»ÑŒÑÐºÐ¸Ð¹': 'pt',
      'ÐÐ¸Ð´ÐµÑ€Ð»Ð°Ð½Ð´ÑÐºÐ¸Ð¹': 'nl',
      'Ð ÑƒÑÑÐºÐ¸Ð¹': 'ru',
      'Ð¯Ð¿Ð¾Ð½ÑÐºÐ¸Ð¹': 'ja',
      'ÐšÐ¾Ñ€ÐµÐ¹ÑÐºÐ¸Ð¹': 'ko',
      'ÐÑ€Ð°Ð±ÑÐºÐ¸Ð¹': 'ar',
      'Ð‘ÐµÐ½Ð³Ð°Ð»ÑŒÑÐºÐ¸Ð¹': 'bn',
      'Ð¥Ð¸Ð½Ð´Ð¸': 'hi',
      'Ð˜Ð½Ð´Ð¾Ð½ÐµÐ·Ð¸Ð¹ÑÐºÐ¸Ð¹': 'id',
      'ÐœÐ°Ð»Ð°Ð¹ÑÐºÐ¸Ð¹': 'ms',
      'Ð¢ÑƒÑ€ÐµÑ†ÐºÐ¸Ð¹': 'tr',
      'Ð’ÑŒÐµÑ‚Ð½Ð°Ð¼ÑÐºÐ¸Ð¹': 'vi',
      'Ð¢Ð°Ð¹ÑÐºÐ¸Ð¹': 'th',
      'Ð¤Ð¸Ð»Ð¸Ð¿Ð¿Ð¸Ð½ÑÐºÐ¸Ð¹': 'tl',
      'Ð˜Ð²Ñ€Ð¸Ñ‚': 'he',
      'ÐŸÐ¾Ð»ÑŒÑÐºÐ¸Ð¹': 'pl',
      'Ð£ÐºÑ€Ð°Ð¸Ð½ÑÐºÐ¸Ð¹': 'uk',
      'Ð§ÐµÑˆÑÐºÐ¸Ð¹': 'cs',
      'Ð¨Ð²ÐµÐ´ÑÐºÐ¸Ð¹': 'sv',
      'ÐÐ¾Ñ€Ð²ÐµÐ¶ÑÐºÐ¸Ð¹': 'no',
      'Ð”Ð°Ñ‚ÑÐºÐ¸Ð¹': 'da',
      'Ð¤Ð¸Ð½ÑÐºÐ¸Ð¹': 'fi',
      'Ð“Ñ€ÐµÑ‡ÐµÑÐºÐ¸Ð¹': 'el',
      'Ð’ÐµÐ½Ð³ÐµÑ€ÑÐºÐ¸Ð¹': 'hu',
      'Ð ÑƒÐ¼Ñ‹Ð½ÑÐºÐ¸Ð¹': 'ro',
      'Ð¡Ð»Ð¾Ð²Ð°Ñ†ÐºÐ¸Ð¹': 'sk',
      'Ð›Ð¸Ñ‚Ð¾Ð²ÑÐºÐ¸Ð¹': 'lt',
      'Ð›Ð°Ñ‚Ð²Ð¸Ð¹ÑÐºÐ¸Ð¹': 'lv',
      'Ð­ÑÑ‚Ð¾Ð½ÑÐºÐ¸Ð¹': 'et',
      'Ð¡ÐµÑ€Ð±ÑÐºÐ¸Ð¹': 'sr',
      'Ð¥Ð¾Ñ€Ð²Ð°Ñ‚ÑÐºÐ¸Ð¹': 'hr',
      'Ð‘Ð¾Ð»Ð³Ð°Ñ€ÑÐºÐ¸Ð¹': 'bg',
      'Ð˜ÑÐ»Ð°Ð½Ð´ÑÐºÐ¸Ð¹': 'is',
      'ÐœÐ°ÐºÐµÐ´Ð¾Ð½ÑÐºÐ¸Ð¹': 'mk',
      'Ð¡Ð»Ð¾Ð²ÐµÐ½ÑÐºÐ¸Ð¹': 'sl',
      'ÐœÐ°Ð»ÑŒÑ‚Ð¸Ð¹ÑÐºÐ¸Ð¹': 'mt',
      'Ð“Ñ€ÑƒÐ·Ð¸Ð½ÑÐºÐ¸Ð¹': 'ka',
      'ÐÑ€Ð¼ÑÐ½ÑÐºÐ¸Ð¹': 'hy',
      'ÐÐ·ÐµÑ€Ð±Ð°Ð¹Ð´Ð¶Ð°Ð½ÑÐºÐ¸Ð¹': 'az',
      'ÐÐ»Ð±Ð°Ð½ÑÐºÐ¸Ð¹': 'sq',
      'Ð£Ð·Ð±ÐµÐºÑÐºÐ¸Ð¹': 'uz',
      'Ð‘ÐµÐ»Ð¾Ñ€ÑƒÑÑÐºÐ¸Ð¹': 'be',
      'ÐšÐ°Ð·Ð°Ñ…ÑÐºÐ¸Ð¹': 'kk'
    };

    return languageCodes[site_language] || 'en'; // ÐŸÐ¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ 'en', ÐµÑÐ»Ð¸ ÑÐ·Ñ‹Ðº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½
  }

 

  console.log('processSitesFromSQS: Processing message for:', track_id);
  console.log('Inputs:', { webhook, track_id, site_type, site_theme, site_language, contact_country, file_extension, site_count, rename_index, edit_after_generation, key_words, stop_words, domain_name });
  
 sendToClientWithUserId(track_id, 'Ð¡Ñ‚Ð°Ñ€Ñ‚ Ð’Ð°Ð¹Ñ‚Ð¿ÐµÐ¹Ð´Ð¶...');


 let newIndex = '';

  newIndex = rename_index;

  let key_words_new = '';
  let stop_words_new = '';

  try {
    if (!key_words || key_words === '' ) {
      //throw new Error("No keywords provided for Unsplash search");
      if (stop_words != ''){
        stop_words_new = `Do not use any of "stop words" in any transcript and any combination, "stop words": ${stop_words}`
        //console.log('stop_words_new: ', stop_words_new)
        key_words_new = await jsonResponseMainKeyWords(site_theme, stop_words_new);
        key_words = key_words_new.key_words;

      }
      else{
        stop_words_new = `Do not use any harmful, illegal, unethical, or violent content stop words of any kind in generating key words`
       // console.log('stop_words_new: ', stop_words_new)
        key_words_new = await jsonResponseMainKeyWords(site_theme, stop_words_new);
        key_words = key_words_new.key_words;
      }
     

    }
    else {
      if (stop_words != '') {
        stop_words_new = `Do not use any of stop words: ${stop_words}`
       // console.log('stop_words_new: ', stop_words_new)
        key_words_new = await jsonResponseMainKeyWords(key_words, stop_words_new);
        

      }
      else {
        stop_words_new = `Do not use any harmful, illegal, unethical, or violent content sopp words of any kind in generating key words`
        console.log('stop_words_new: ', stop_words_new)
        key_words_new = await jsonResponseMainKeyWords(key_words, stop_words_new);
       
      }
    }

    //sendToClientWithUserId(track_id, 'ÐÐ°Ñ‡Ð¸Ð½Ð°ÐµÐ¼ Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸ÑŽ Ð’Ð°Ð¹Ñ‚Ð¿ÐµÐ¹Ð´Ð¶...');

    let prompt = ''
    prompt = `Generate unique text for ${site_theme} website in ${site_language} for ${contact_country}`;
    const webhookUrl = `https://aisitegen.onrender.com/api/v1/generatorTelegram/webhook/?user_id=${encodeURIComponent(track_id)}`;

    console.log('Loading... Start Generating Text for prompt:', prompt);
    // sendToClientWithUserId(track_id,  'Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼' );

    let domain_to_ai = ''; // Initialize as empty
    


    console.log('ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½ domain_name:', domain_name);

  // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ domain_name ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾
  let processedDomainName = domain_name.trim();

  // Ð£Ð±Ð¸Ñ€Ð°ÐµÐ¼ 'www.' ÐµÑÐ»Ð¸ Ð¿Ñ€Ð¸ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚
  if (processedDomainName.startsWith('www.')) {
    processedDomainName = processedDomainName.substring(4);
  }

  const domainParts = processedDomainName.split('.');
  let brandName = '';

  if (domainParts.length > 0 && domainParts[0] !== '') {
    brandName = domainParts[0];
}  else {
    brandName = '';
  }

  let domain_to_policy = processedDomainName;

   // let brandName = domain_name.replace(/^(?:https?:\/\/)?(?:www\.)?(?:[^.]+\.)*([^.]+)\.[^.]+(?:\/.*)?$/, '$1');
    console.log('brandName', brandName)

    if (domain_name === '') {
      domain_to_ai = `- ** Brand Name **: generate a one word brand name on ${site_language} language for the business that aligns with the ${site_theme} and response as "brand_name".`;
      domain_name = `- ** Brand Name **: generate a one word domain brand name on ${site_language} language for the business that aligns with the ${site_theme} and response as "brand_name".`;
    } else {

      domain_to_ai = `- ** Brand Name **: Use brand name as it is and do not translate to ${site_language}, domain name: " ${brandName} ", do not change it and use in website text as ${brandName} and response as: "brand_name".`;
    }

    console.log('domain_name ', domain_name )

    let stop_words_ai = ''; // Initialize as empty

    if (stop_words === '') {
      stop_words_ai = '';

    } else {
      stop_words_ai = `- ** Stop Words **: Do not use in text generation any of this stop words: ${stop_words} ".`;
    }

    let jsonResponse = ''

    sendToClientWithUserId(track_id, 'ðŸ¢ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¢ÐµÐºÑÑ‚ Ð“Ð»Ð°Ð²Ð½Ð¾Ð¹ Ð¡Ñ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹...');
    jsonResponse = await generateTextFromGPT4o(site_type, site_theme, site_language, contact_country, key_words, domain_to_ai, brandName, stop_words_ai, track_id);

    let thankyouResponse = '';
     thankyouResponse = await translatedThankYouFromGPT4o(site_language);

   // console.log('thankyouResponse:', thankyouResponse);

    let thankyou = thankyouResponse.thank_you;
    let thankyoutext = thankyouResponse.thank_you_text;

    let promptImages = '';

    promptImages = jsonResponse.images_key_word; //translated to EN keywords

    //  promptImages = site_theme;

    let blogTitlesJsonResponse = '';

    let blog_context = '';

    blog_context = jsonResponse.service_text_01;

    let product_context = '';

    product_context = jsonResponse.product;

    let keywords_generated_ai = '';

    keywords_generated_ai = jsonResponse.keywords_head;

    let promptGeneratedResponse = '';
    let promptGeneratedResponse2 = '';
    let promptGeneratedResponse3 = '';
    let promptGeneratedResponseProduct = '';



    blogTitlesJsonResponse = await generateBlogTitlesFromGPT4o(blog_context, product_context, site_type, site_theme, site_language, keywords_generated_ai, stop_words_ai)

   

    let promptBlogTitle1 = '';
    let promptBlogShortText1 = '';
    let promptBlogTitle2 = '';
    let promptBlogShortText2 = '';
    let promptBlogTitle3 = '';
    let promptBlogShortText3 = '';
    let promptImages2 = '';
    let promptImages3 = '';

    promptBlogTitle1 = blogTitlesJsonResponse.blog_title_001;
    promptBlogShortText1 = blogTitlesJsonResponse.blog_text_001;
    promptBlogTitle2 = blogTitlesJsonResponse.blog_title_002;
    promptBlogShortText2 = blogTitlesJsonResponse.blog_text_002;
    promptBlogTitle3 = blogTitlesJsonResponse.blog_title_003;
    promptBlogShortText3 = blogTitlesJsonResponse.blog_text_003;



    let promptImagesContext = '';
    let promptImagesContext2 = '';
    let promptImagesContext3 = '';
    let promptImagesProduct = '';

     promptImagesContext = promptBlogShortText1;
     promptImagesContext2 = promptBlogShortText2;
     promptImagesContext3 = promptBlogShortText3;

    promptGeneratedResponseProduct = await generatePromptsFromGPT4oMain( product_context, site_theme, keywords_generated_ai);
    promptGeneratedResponse = await generatePromptsFromGPT4o(promptImagesContext, product_context, site_theme, keywords_generated_ai, promptBlogTitle1);
    promptGeneratedResponse2 = await generatePromptsFromGPT4o2(promptImagesContext2, product_context, site_theme, keywords_generated_ai, promptBlogTitle2);
    promptGeneratedResponse3 = await generatePromptsFromGPT4o3(promptImagesContext3, product_context, site_theme, keywords_generated_ai, promptBlogTitle3);

    promptImages = promptGeneratedResponse.prompt_1
    promptImages2 = promptGeneratedResponse2.prompt_2
    promptImages3 = promptGeneratedResponse3.prompt_3
    promptImagesProduct = promptGeneratedResponseProduct.prompt

   // console.log('Blog Titles and Short Texts:', { promptBlogTitle1, promptBlogShortText1, promptBlogTitle2, promptBlogShortText2, promptBlogTitle3, promptBlogShortText3 });

    let slug1TR = '';
    let slug2TR = '';
    let slug3TR = '';

    slug1TR = await transliterateAndSlugify(promptBlogTitle1);
    slug2TR = await transliterateAndSlugify(promptBlogTitle2);
    slug3TR = await transliterateAndSlugify(promptBlogTitle3);

    let slug1 = '';
    let slug2 = '';
    let slug3 = '';

    slug1 = await transliterateAndSlugifyLatinArabic(slug1TR)
    slug2 = await transliterateAndSlugifyLatinArabic(slug2TR)
    slug3 = await transliterateAndSlugifyLatinArabic(slug3TR)

   // console.log("blog_slug_001: ", slug1);
   // console.log("url11: ", slug1);

   // console.log('Generated Slugs:', { slug1, slug2, slug3 });

    let promptImagesAi = '';

    promptImagesAi = keywords_generated_ai;
    //promptImagesAi = key_words;

    // // keywords_generated_ai

    const promptAddon = ', photography, hyper-realistic, detailed 8k, ultra-detailed, masterpiece, best quality, dslr, ultra quality, sharp focus, tack sharp, dof, film grain, Fujifilm XT3, crystal clear, 8K UHD'

    let newImagePrompt = '';
    let newImagePrompt2 = '';
    let newImagePrompt3 = '';
    let newImagePromptProduct = '';


    newImagePrompt = promptImages + promptAddon
    newImagePrompt2 = promptImages2 + promptAddon
    newImagePrompt3 = promptImages3 + promptAddon
    newImagePromptProduct = promptImagesProduct + promptAddon;

    sendToClientWithUserId(track_id, 'ðŸ–¼ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Ð˜Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ Ð´Ð»Ñ Ð“Ð»Ð°Ð²Ð½Ð¾Ð¹ Ð¡Ñ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹...');

    const imagesAiResponse = await replicateResponse(newImagePrompt);
    const imagesAiResponse2 = await replicateResponse(newImagePrompt2);
    const imagesAiResponse3 = await replicateResponse(newImagePrompt3);
    const imagesAiResponseProduct = await replicateResponse(newImagePromptProduct);


   // console.log("imagesAiResponse: ", imagesAiResponse)


    sendToClientWithUserId(track_id, 'ðŸ“ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Ð‘Ð»Ð¾Ð³: CÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ð° 1.');

    const jsonResponseBlog = await generateTextBlogFromGPT4o(site_type, site_theme, site_language, contact_country, key_words, promptBlogTitle1, promptBlogShortText1);

    sendToClientWithUserId(track_id, 'ðŸ“ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Ð‘Ð»Ð¾Ð³: CÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ð° 2.');
   // console.log('Generated Slugs:', 'Generating text for blog page 2.');

    const jsonResponseBlog2 = await generateTextBlog2FromGPT4o(site_type, site_theme, site_language, contact_country, key_words, promptBlogTitle2, promptBlogShortText2);

    sendToClientWithUserId(track_id, 'ðŸ“ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Ð‘Ð»Ð¾Ð³: CÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ð° 3.');
    const jsonResponseBlog3 = await generateTextBlog3FromGPT4o(site_type, site_theme, site_language, contact_country, key_words, promptBlogTitle3, promptBlogShortText3);

    // sendToClientWithUserId(track_id, { status: 'translate_images_key_words', message: 'Translation...' });
    const usplash_key_words = await translatedTextFromGPT4o(promptImages, site_language);

   // console.log('images_key_word:', usplash_key_words);

    // sendToClientWithUserId(track_id, { status: 'images_key_words', message: 'Final Key Words:' + usplash_key_words });
    sendToClientWithUserId(track_id, 'ðŸ–¼ï¸ ÐŸÐ¾Ð´Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ðµ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ');

    //const imageUrls = await fetchImagesFromUnsplash(promptImages, 8);
    const imageUrls = await fetchImagesFromPexels(promptImages, 8);

    async function fetchImagesRandomly(promptImages, numImages = 8) {
      // Randomly select a function to call (either Unsplash or Pexels)
      const randomChoice = Math.random() < 0.5 ? 'unsplash' : 'pexels';
    //  console.log(`Randomly selected ${randomChoice} API`);

      if (randomChoice === 'unsplash') {
        return await fetchImagesFromUnsplash(promptImages, numImages);
      } else {
        return await fetchImagesFromPexels(promptImages, numImages);
      }
    }

    // Usage example
    // const imageUrls = await fetchImagesRandomly(promptImages, 8);



    //  const imageUrls = imagesAiResponse;


    const imageVariables = {};
    imageUrls.forEach((url, index) => {
      if (url) {
        const placeholder = `image_00${index + 1}`;
        imageVariables[placeholder] = url;
       // console.log(`Image URL set for ${placeholder}: ${url}`);
      } else {
        console.log(`No image URL found for image_00${index + 1}`);
      }
    });

    sendToClientWithUserId(track_id, 'ðŸ—‚ï¸ Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Ð²Ð½ÑƒÑ‚Ñ€ÐµÐ½Ð½Ð¸Ðµ ÑÑÑ‹Ð»ÐºÐ¸.');
   // console.log('Fetched images:', imageVariables);

    const teamImages = await fetchTeamMemberImages();

   // console.log('Fetched team member images:', teamImages);

    let fullResponse = '';
    let brandnamepolicy = '';
    brandnamepolicy = domain_to_policy;
    let fullResponseThankyou = '';


    const lang_attr = getLangAttr(site_language);

    fullResponse = {
      ...jsonResponse,
      ...imageVariables,
      ...teamImages,
      blog_slug_001: slug1,
      blog_slug_002: slug2,
      blog_slug_003: slug3,
      blog_title_001: promptBlogTitle1,
      blog_text_001: promptBlogShortText1,
      blog_title_002: promptBlogTitle2,
      blog_text_002: promptBlogShortText2,
      blog_title_003: promptBlogTitle3,
      blog_text_003: promptBlogShortText3,
      brand_name_policy: brandnamepolicy,
      lang_attr: lang_attr
    };

     fullResponseThankyou = { 
      ...jsonResponse,
      ...thankyouResponse,
       lang_attr: lang_attr
     //  thank_you: thankyou,
     //  thank_you_text: thankyoutext
    }
   
    //console.log('fullResponseThankyou: ', fullResponseThankyou)

    const fullResponseBlog = {
      ...jsonResponse, ...jsonResponseBlog, ...imageVariables,
      blog_slug_001: slug1,
      blog_slug_002: slug2,
      blog_slug_003: slug3,
      blog_slug_001: slug1,
      blog_slug_002: slug2,
      blog_slug_003: slug3,
      blog_title_001: promptBlogTitle1,
      blog_text_001: promptBlogShortText1,
      blog_title_002: promptBlogTitle2,
      blog_text_002: promptBlogShortText2,
      blog_title_003: promptBlogTitle3,
      blog_text_003: promptBlogShortText3,
      lang_attr: lang_attr
    };
    const fullResponseBlog2 = {
      ...jsonResponse, ...jsonResponseBlog2, ...imageVariables,
      blog_slug_001: slug1,
      blog_slug_002: slug2, blog_slug_003: slug3, blog_slug_001: slug1,
      blog_slug_002: slug2,
      blog_slug_003: slug3,
      blog_title_001: promptBlogTitle1,
      blog_text_001: promptBlogShortText1,
      blog_title_002: promptBlogTitle2,
      blog_text_002: promptBlogShortText2,
      blog_title_003: promptBlogTitle3,
      blog_text_003: promptBlogShortText3,
      lang_attr: lang_attr
    };
    const fullResponseBlog3 = {
      ...jsonResponse, ...jsonResponseBlog3, ...imageVariables,
      blog_slug_001: slug1,
      blog_slug_002: slug2,
      blog_slug_003: slug3,
      blog_slug_001: slug1,
      blog_slug_002: slug2,
      blog_slug_003: slug3,
      blog_title_001: promptBlogTitle1,
      blog_text_001: promptBlogShortText1,
      blog_title_002: promptBlogTitle2,
      blog_text_002: promptBlogShortText2,
      blog_title_003: promptBlogTitle3,
      blog_text_003: promptBlogShortText3,
      lang_attr: lang_attr
    };

    sendToClientWithUserId(track_id, 'ðŸ› ï¸ Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð½Ð°Ð²Ð¸Ð³Ð°Ñ†Ð¸ÑŽ Ð¸ ÑÑÑ‹Ð»ÐºÐ¸');


    let randomTemplate = '';
    let randomTemplateAssets = '';

    // Function to randomly return "blocks", "blocks2", or "blocks3"
    function getRandomTemplateName() {
      const randomValue = Math.random();
      if (randomValue < 0.33) {
        return 'blocks3';
      } else if (randomValue < 0.66) {
        return 'blocks2';
      } else {
        return 'blocks';
      }
    }

    // Use the function to set the randomTemplate variable
  randomTemplate = getRandomTemplateName();
 // randomTemplate = 'blocks2'

    if (randomTemplate === 'blocks') {
      randomTemplateAssets = '001';
    } else if (randomTemplate === 'blocks2') {
      randomTemplateAssets = '002';
    } else {
      randomTemplateAssets = '003';
    }


     // Function to randomly return "blocks", "blocks2", or "blocks3"
   //  function getRandomTemplateName() {
    //  const randomValue = Math.random();
   //   if (randomValue < 0.25) {
    //    return 'blocks3';
    //  } else if (randomValue < 0.50) {
    //    return 'blocks2';
    //  } else if (randomValue < 0.75){
    //    return 'blocks4';
    //  }
   //  else {
   //   return 'blocks';
  //  }
   // }

    // Use the function to set the randomTemplate variable
  //randomTemplate = getRandomTemplateName();
  //randomTemplate = 'blocks4'

      // if (randomTemplate === 'blocks') {
      //    randomTemplateAssets = '001';
      // } else if (randomTemplate === 'blocks2') {
      //   randomTemplateAssets = '002';
      // } else if (randomTemplate === 'block3') {
      //    randomTemplateAssets = '003';
       // } else {
       //     randomTemplateAssets = '004';
       //  }


    let extension = file_extension;
    let zipFilePath;

    const combinedHTML = buildHtmlTemplate(randomTemplate, track_id);
    const combinedHTMLservices = buildHtmlTemplatServices(randomTemplate, track_id);
    const combinedHTMLabout = buildHtmlTemplatAbout(randomTemplate, track_id);
    const combinedHTMLproduct = buildHtmlTemplateProduct(randomTemplate, track_id);
    const combinedHTMLblog = await buildHtmlTemplateBlog(randomTemplate, track_id);
    const combinedHTMLblog2 = await buildHtmlTemplateBlog2(randomTemplate, track_id);
    const combinedHTMLblog3 = await buildHtmlTemplateBlog3(randomTemplate, track_id);
    const combinedHTMLpolicy = await buildHtmlTemplatePolicy(site_language, randomTemplate, track_id);
    const combinedPHP = await buildPhpTemplate(randomTemplate, track_id);

    
    const combinedPHPblog = await buildPHPTemplateBlog(randomTemplate, track_id);
    const combinedPHPblog2 = await buildPHPTemplateBlog2(randomTemplate, track_id);
    const combinedPHPblog3 = await buildPHPTemplateBlog3(randomTemplate, track_id);

    const generatedPHPblog = await generateHTML(combinedPHPblog, fullResponseBlog);
    const generatedPHPblog2 = await generateHTML(combinedPHPblog2, fullResponseBlog2);
    const generatedPHPblog3 = await generateHTML(combinedPHPblog3, fullResponseBlog3);

    const combinedPHPservices = buildHtmlTemplatServicesPHP(randomTemplate, track_id);
    const combinedPHPabout = buildHtmlTemplatAboutPHP(randomTemplate, track_id);
    const combinedPHPproduct = buildHtmlTemplateProductPHP(randomTemplate, track_id);
    const combinedHTMLpolicyPHP = await buildHtmlTemplatePolicyPHP(site_language, randomTemplate, track_id);
    

    const generatedHTML = await generateHTML(combinedHTML, fullResponse);
    const generatedPHP = await generateHTML(combinedPHP, fullResponse);

    
   

    const generatedHTMLservices = await generateHTML(combinedHTMLservices, fullResponse);
    const generatedHTMLabout = await generateHTML(combinedHTMLabout, fullResponse);
    const generatedHTMLproduct = await generateHTML(combinedHTMLproduct, fullResponse);

    const generatedPHPservices = await generateHTML(combinedPHPservices, fullResponse);
    const generatedPHPLabout = await generateHTML(combinedPHPabout, fullResponse);
    const generatedPHPproduct = await generateHTML(combinedPHPproduct, fullResponse);
    const generatedHTMLpolicy = await generateHTML(combinedHTMLpolicy, fullResponse);

    const generatedPHPpolicy = await generateHTML(combinedHTMLpolicyPHP, fullResponse);
    const generatedHTMLblog = await generateHTML(combinedHTMLblog, fullResponseBlog);
    const generatedHTMLblog2 = await generateHTML(combinedHTMLblog2, fullResponseBlog2);
    const generatedHTMLblog3 = await generateHTML(combinedHTMLblog3, fullResponseBlog3);

    if (extension === 'PHP') {

     
      const combinedHTMLthankyouPHP = await buildHtmlTemplateThankyouPHP(randomTemplate, track_id);

      const generatedHTMLthankyouPHP = await generateHTML(combinedHTMLthankyouPHP, fullResponseThankyou);

 

      sendToClientWithUserId(track_id, 'ðŸ“¦ Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ ZIP ÐÑ€Ñ…Ð¸Ð²');
      zipFilePath = await savePhpToZip(newIndex, generatedPHP, generatedPHPservices, generatedPHPLabout, generatedPHPproduct, generatedPHPpolicy, generatedPHPblog, generatedPHPblog2, generatedPHPblog3, slug1, slug2, slug3, track_id, imagesAiResponse, imagesAiResponse2, imagesAiResponse3, imagesAiResponseProduct, randomTemplateAssets, generatedHTMLthankyouPHP);

    }

    else {
      const combinedHTMLthankyou = await buildHtmlTemplateThankyou(randomTemplate, track_id);
      const generatedHTMLthankyou = await generateHTML(combinedHTMLthankyou, fullResponseThankyou);
     sendToClientWithUserId(track_id, 'ðŸ“¦ Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ ZIP ÐÑ€Ñ…Ð¸Ð²');
    

      zipFilePath = await saveHtmlToZip(newIndex, generatedHTML, generatedHTMLservices, generatedHTMLabout, generatedHTMLproduct, generatedHTMLpolicy, generatedHTMLblog, generatedHTMLblog2, generatedHTMLblog3, slug1, slug2, slug3, track_id, imagesAiResponse, imagesAiResponse2, imagesAiResponse3, imagesAiResponseProduct, randomTemplateAssets, generatedHTMLthankyou);

    }



    // Function to generate a random 15-digit number
    function generateRandom15DigitNumber() {
      return Math.floor(Math.random() * 10 ** 15).toString().padStart(15, '0');
    }

    let randomNumber = '';
    randomNumber = generateRandom15DigitNumber();
   // console.log("randomNumber:", randomNumber)

    const s3BucketName = process.env.AWS_S3_BUCKET_NAME;
    const s3Key = `${track_id}_${randomNumber}.zip`;
 
      const s3Url = await uploadToS3(zipFilePath, s3BucketName, s3Key);
   
  

    const status = 'succeeded';

    await sendToWebhook(webhookUrl, { track_id, s3Url, webhookUrl, status });

  //  console.log('API Request Successful');
  } catch (error) {
    console.error('Error processing site:', error);
    sendToClientWithUserId(track_id, { status: 'processing_failed' });
  }
}


export { sendToClientWithUserId, processSitesFromSQS, addClient, removeClient };

// Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð½Ð¾Ð²ÑƒÑŽ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð´Ð»Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ ÑÐ°Ð¹Ñ‚Ð° Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ LLM
async function generateSiteWithLLM(siteConfig) {
  // ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ ÑÐ°Ð¹Ñ‚Ð°
  const { track_id, site_type, site_theme, site_language, contact_country, 
          key_words, site_style, domain_name } = siteConfig;
  
  // Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð¼Ð¿Ñ‚Ð° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÑÑ‚Ð¸Ð»Ñ ÑÐ°Ð¹Ñ‚Ð°
  const prompt = createPromptByStyle(site_style, siteConfig);
  
  // ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ðº Replicate API
  const siteContent = await replicateLLMRequest(prompt);
  
  // ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÑÐ°Ð¹Ñ‚Ð°
  return processLLMResponse(siteContent, siteConfig);
}
